%%\VignetteIndexEntry{crmPack: Object-oriented implementation of CRM designs}
%%\VignetteKeywords{dose escalation, CRM, N-CRM, EWOC, Bayesian adaptive design}
%%\VignettePackage{crmPack}
%%\VignetteDepends{crmPack,ggmcmc,grid}

\documentclass[UKenglish]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[UKenglish]{babel}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{url}
\usepackage[sumlimits, intlimits, namelimits]{amsmath} % Math
\usepackage{amssymb}                                   % Symbols
\usepackage[caption = true]{subfig}
\usepackage[longnamesfirst,round]{natbib}
\usepackage{tikz}
\usepackage[nogin]{mySweave}            % use the customized Sweave style


\begin{document}

%% reduce the height of the plots
\setkeys{Gin}{width=0.65\textwidth}

%% no indentation of paragraphs
\noindent

\title{Using the package \texttt{crmPack}:\\ an introductory example.}
\author{Daniel Saban\'es Bov\'e}
\maketitle

This short vignette shall introduce into the usage of the package
\texttt{crmPack}. Hopefully it makes it easy for you to set up your own CRM.

If you have any questions or feedback concerning the package, please write an
email to me:
\href{mailto:sabanesd@roche.com}{\nolinkurl{sabanesd@roche.com}}.
Thank you very much in advance!

<<setup, echo=FALSE, results=hide>>=
options(continue="  ")                  # use two blanks instead of "+" for
                                        # continued lines (for easy copying)
@

\section{Installation}
\label{sec:installation}

Probably you have already installed the package. However, if not, here is a
brief installation summary.

\texttt{crmPack} is relying on
\href{https://github.com/armstrtw/rcppbugs}{rcppbugs},
\href{http://www.openbugs.net}{OpenBUGS} and
\href{http://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-winbugs/}{WinBUGS}
(please click on the links for going to the webpages of the two projects) for
the internal MCMC computations. While OpenBUGS is required for the default MCMC
runs, WinBUGS only needs to be installed currently if the dual-endpoint designs
need to be run (because they don't run with OpenBUGS). To increase the speed of
the MCMC sampling, rcppbugs is currently used for the \texttt{LogisticNormal}
model.

Furthermore, you first have to install some required packages, with the
following command:
<<install-others, eval=FALSE>>=
install.packages(c("Rcpp", "RcppArmadillo", "rcppbugs",
	           "R2WinBUGS", "ggplot2", "gridExtra", "GenSA", "mvtnorm"),
                 dependencies=TRUE)
@

Finally, you can obtain the newest version of the package.
Download it by visiting the following URL:
\url{https://stash.intranet.roche.com/stash/plugins/servlet/archive/projects/RSTAT/repos/crmpack?at=refs%2Fheads%2Fmaster}
This will download a file called \texttt{crmpack-master.zip}. You then extract
the zip file to a folder \texttt{crmpack-master}. Afterwards you can
install the package from this folder, e.g. from within \texttt{R} using the
command
<<install-crmpack, eval=FALSE>>=
install.packages("path/to/the/directory/crmpack-master",
                 repos=NULL,
                 type="source")
@
Note that you have to specify the full directory to \texttt{crmpack-master}, unless
this is a subdirectory of your current working directory.

\section{Getting started}
\label{sec:getting-started}

Before being able to run anything, you have to load the package with
<<load>>=
library(crmPack)
@

For browsing the help pages for the package, it is easiest to start the web
browser interface with
<<webinterface, eval=FALSE>>=
help.start()
@
then clicking on ``Packages'' and then searching for ``crmPack'' and clicking on
the link. This gives you the list of all help pages available for the package.

First, we will set up a logistic normal model. Therefore, you can now click on
the corresponding help page \texttt{LogisticNormal-class} as background
information for the next steps.

\section{Model setup}
\label{sec:model-setup}

\subsection{Logistic model with bivariate normal prior}
\label{sec:logist-norm-model}

Let us start with setting up the logistic regression model, which will then be
used in the following for the continual reassessment method. With the following
command, we create a new model of class \texttt{LogisticNormal}, with certain
mean and covariance prior parameters and reference dose:

<<model-setup>>=
model <- new("LogisticNormal",
             mean=c(-0.85, 1),
             cov=
             matrix(c(1, -0.5, -0.5, 1),
                    nrow=2L),
             refDose=56)
@

This command may look unfamiliar to you, because it uses the \texttt{new}
function. This is a special function in \texttt{R}, as it creates new objects of
the class specified by its first argument (here: \texttt{"LogisticNormal"}). The
\texttt{R}-package \texttt{crmPack} uses the S4 class system for implementation
of the CRM designs. We can query the class an object belongs to with the
\texttt{class} function:

<<class>>=
class(model)
@

We can look in detail at the structure of \texttt{model} as follows:

<<str>>=
str(model)
@

We see that the object has \Sexpr{length(slotNames(model))} slots, and their
names. These can be accessed with the \verb|@| operator (similarly as for lists
the \verb|$| operator), for example we can extract the \texttt{dose} slot:

<<dose>>=
model@dose
@

This is the function that computes for a given probability \texttt{prob} and
parameters \texttt{alpha0} and \texttt{alpha1} the dose that gives this
probability. You can find out yourself about the other slots, by looking at the
help page for \texttt{Model-class} in the help browser, because all models
are just special cases of the general \texttt{Model} class. In the
\texttt{Model-class} help page, you also find out that there are two additional
specific model classes, namely \texttt{LogisticKadane} and
\texttt{DualEndpoint}.

\subsection{Advanced model specification}
\label{sec:advanc-model-spec}

There are a few further advanced ways to specify a model in \texttt{crmPack}.

First, a minimal informative prior \citep{Neuenschwander2008} can be computed
using the \texttt{MinimalInformative} function. The construction is based on the
input of a minimal and a maximal dose, where certain ranges of DLT probabilities
are deemed unlikely. A logistic function is then fitted through the
corresponding points on the dose-toxicity plane in order to derive Beta
distributions also for doses in-between. Finally these Beta distributions are
approximated by a common \texttt{LogisticNormal} model. So the minimal informative
construction avoids explicit specification of the parameters of the
\texttt{LogisticNormal} model.

In our example, we could construct it as follows, assuming a minimal dose of 0.1
mg and a maximum dose of 100 mg:

<<min-inf>>=
set.seed(432)
coarseGrid <- c(0.1, 10, 30, 60, 100)
minInfModel <- MinimalInformative(dosegrid = coarseGrid,
                                  refDose=50,
                                  threshmin=0.2,
                                  threshmax=0.3,
                                  control=
                                  list(threshold.stop=0.03,
                                       maxit=200))
@


We use a few grid points between the minimum and the maximum to guide the
approximation routine, which is based on a stochastic optimization method (the
\texttt{control} argument is for this optimization routine, please see the help
page for \texttt{Quantiles2LogisticNormal} for details). Therefore we need to
set a random number generator seed beforehand to be able to reproduce the
results in the future. The \texttt{threshmin} and \texttt{threshmax} values
specify the probability thresholds above and below, respectively, it is very
unlikely (only 5\% probability) of the probability of DLT at the minimum and
maximum dose, respectively.

The result \texttt{minInfModel} is a list, and we can use its contents to
illustrate the creation of the prior:

<<min-inf-res, fig=TRUE>>=
matplot(x=coarseGrid,
        y=minInfModel$required,
        type="b", pch=19, col="blue", lty=1,
        xlab="dose",
        ylab="prior probability of DLT")
matlines(x=coarseGrid,
         y=minInfModel$quantiles,
         type="b", pch=19, col="red", lty=1)
@

In this plot we see in blue the quantiles (2.5\%, 50\%, and 97.5\%) of
the Beta distributions that we approximate with the red quantiles of the
logistic normal model. We see that the distance is quite small, and the maximum
distance between any red and blue point is:

<<min-inf-dist>>=
minInfModel$distance
@

The final approximating model, which has produced the red points, is contained
in the \texttt{model} element:

<<min-inf-model>>=
str(minInfModel$model)
@

Here we see in the slots \texttt{mean}, \texttt{cov} the parameters that have
been determined. At this point a slight warning: you cannot directly change
these parameters in the slots of the existing model object, because the
parameters have also been saved invisibly in other places in the model object.
Therefore, always use the \texttt{new} command with the new parameters to create
a new model object.

\section{Data}
\label{sec:data}

If you are in the middle of a trial and you would like to recommend the next
dose, then you have data from the previous patients for input into the model.
This data needs to be captured in a \texttt{Data} object. For example:

<<data>>=
data <- new("Data",
            x=
            c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
            y=
            as.integer(c(0, 0, 0, 0, 0, 0, 1, 0)),
            cohort=
            as.integer(c(0, 1, 2, 3, 4, 5, 5, 5)),
            doseGrid=
            c(0.1, 0.5, 1.5, 3, 6,
              seq(from=10, to=80, by=2)))
@

Most important are \texttt{x} (the doses) and \texttt{y} (the DLTs, 0 for no DLT
and 1 for DLT), as well as the dose grid \texttt{doseGrid}. All computations are
using the dose grid specified in the \texttt{Data} object. So for example,
except for patient number 7, all patients were free of DLTs.

Again, you can find out the details in the help page \texttt{Data-class}. Note
that you have received a warning here, because you did not specify the patient
IDs -- however, automatic ones just indexing the patients have been created for
you:

<<ids>>=
data@ID
@

You can get a visual summary of the data by applying \texttt{plot} to the
object:\footnote{Note that for all \texttt{plot} calls in this vignette, you can
  leave away the wrapping \texttt{print} function call if you are working
  interactively with \texttt{R}. It is only because of the \texttt{Sweave}
  production of this vignette that the \texttt{print} statement is needed.}

<<plotdata, fig=TRUE>>=
print(plot(data))
@

\section{Obtaining the posterior}
\label{sec:obtaining-posterior}

As said before, \texttt{crmPack} relies on MCMC sampling for obtaining the
posterior distribution of the model parameters, given the data. The MCMC
sampling can be controlled with an object of class \texttt{McmcOptions}, created
for example as follows:

<<mcmc-opts>>=
options <- new("McmcOptions",
               burnin=100,
               step=2,
               samples=1000)
@

Now the object \texttt{options} specifies that you would like to have 1000
parameter samples obtained from a Markov chain that starts with a ``burn-in''
phase of 100 iterations that are discarded, and then save a sample every 2
iterations. Note that these numbers are too low for actual implementation and
only used for illustrating purposes here; normally you would specify at least
the default parameters of the initialization method that is invoked by the
\texttt{new} generic function: $10\,000$ burn-in iterations and $10\,000$
samples saved every 2nd iteration. You can look these up in help browser under
the link ``initialize-method'' (there are multiple of those), described in the
right column with ``Initialization method for the "McmcOptions" class''.

After having set up the options, you can proceed to MCMC sampling by calling the
\texttt{mcmc} function:

<<mcmc-sampling>>=
set.seed(94)
samples <- mcmc(data, model, options)
@

The \texttt{mcmc} function takes the data object, the model and the MCMC
options. As the model here is of class \texttt{LogisticNormal}, the rcppbugs
implementation is used, which is about twice as fast as the WinBUGS code.
However, for other models, by default, the OpenBUGS implementation is used for
obtaining the samples, and you could specify \texttt{program="WinBUGS"} to use
WinBUGS instead.

Finally, it is good practice to check graphically that the Markov chain has
really converged to the posterior distribution. To this end, \texttt{crmPack}
provides an interface to the convenient \texttt{R}-package \texttt{ggmcmc}. With
the function \texttt{extract} you can extract the individual parameters from the
object of class \texttt{Samples}. For example, we extract the $\alpha_{0}$
samples:

<<mcmc-extract>>=
## look at the structure of the samples object:
str(samples)
## now extract the alpha0 samples (intercept of the regression model)
alpha0samples <- extract(samples, "alpha0")
@

\texttt{alpha0samples} now contains the $\alpha_{0}$ samples in a format
understood by \texttt{ggmcmc} and we can produce plots with it, e.g. a trace plot
and an autocorrelation plot:

<<ggmcmc, fig=TRUE>>=
library(ggmcmc)
print(ggs_traceplot(alpha0samples))
@

<<ggmcmc2, fig=TRUE>>=
print(ggs_autocorrelation(alpha0samples))
@

So here we see that we have some autocorrelation in the samples, and might
consider using a higher thinning parameter in order to decrease it.

You can find other useful plotting functions in the package information:

<<ggmcmc-help, eval=FALSE>>=
help(package="ggmcmc")
@

\section{Plotting the model fit}
\label{sec:plot-fit}

After having obtained the parameter samples, we can plot the model fit, by
supplying the samples, model and data to the generic plot function:

<<plot-model-fit, fig=TRUE>>=
print(plot(samples, model, data))
@

This plot shows the posterior mean curve and 95\% equi-tailed credible intervals
at each point of the dose grid from the \texttt{data} object.

Note that you can also produce a plot of the prior mean curve and credible
intervals, i.e. from the model without any data. This works in principle the
same way as with data, just that we use an empty data object:

<<empty-data, fig=TRUE>>=
## provide empty dose and DLT vectors, and use same dose grid
## as before:
emptydata <- new("Data",
                 x=numeric(),
                 y=integer(),
                 doseGrid=data@doseGrid)
## obtain prior samples with this Data object
priorsamples <- mcmc(emptydata, model, options)
## then produce the plot
print(plot(priorsamples, model, emptydata))
@

\section{Escalation Rules}
\label{sec:escalation-rules}

For the dose escalation, there are four kinds of rules:
\begin{enumerate}
\item \texttt{Increments}: For specifying maximum allowable increments between
  doses
\item \texttt{NextBest}: How to derive the next best dose
\item \texttt{CohortSize}: For specifying the cohort size
\item \texttt{Stopping}: Stopping rules for finishing the dose escalation
\end{enumerate}
We have listed here the classes of these rules, and there are multiple
subclasses for each of them, which you can find as links in the help pages
\texttt{Increments-class}, \texttt{NextBest-class}, \texttt{CohortSize-class}
and \texttt{Stopping-class}.

\subsection{Increments rules}
\label{sec:increments-rules}

Let us start with looking in detail at the increments rules. Currently two
specific rules are implemented: Maximum relative increments based on the current
dose (\texttt{IncrementsRelative}), and maximum relative increments based on the
current cumulative number of DLTs that have happened
(\texttt{IncrementsRelativeDLT}).

For example, in order to specify maximum increase of 100\% for doses up to 20 mg,
and 33\% for doses above 20 mg, we can setup the following increments rule:

<<rel-incs>>=
myIncrements <- new("IncrementsRelative",
                    intervals=c(0, 20, Inf),
                    increments=c(1, 0.33))
@

Here the \texttt{intervals} slot specifies the intervals, in which the maximum
relative \texttt{increments} (note: decimal values here, no percentages!) are
valid.

The increments rule is used by the \texttt{maxDose} function to obtain the
maximum allowable dose given the current data:

<<max-dose>>=
nextMaxDose <- maxDose(myIncrements,
                       data=data)
nextMaxDose
@

So in this case, the next dose could not be larger than 20 mg.

\subsection{Rules for next best dose recommendation}
\label{sec:rules-next-best}

There are two implemented rules for toxicity endpoint CRMs: \texttt{NextBestMTD}
that uses the posterior distribution of the MTD estimate (given a target
toxicity probability defining the MTD), and \texttt{NextBestNCRM} that
implements the N-CRM, using posterior probabilities of target-dosing and
overdosing at the dose grid points to recommend a next best dose.

For example, in order to use the N-CRM with target toxicity interval from 20\%
to 35\%, and a maximum overdosing probability of 25\%, we specify:

<<ncrm-spec>>=
myNextBest <- new("NextBestNCRM",
                  target=c(0.2, 0.35),
                  overdose=c(0.35, 1),
                  maxOverdoseProb=0.25)
@

Alternatively, we could use an MTD driven recommendation rule. For example, with
a target toxicity rate of 33\%, and recommending the 25\% posterior quantile of
the MTD, we specify

<<mtd-spec>>=
mtdNextBest <- new("NextBestMTD",
                   target=0.33,
                   derive=
                   function(mtdSamples){
                       quantile(mtdSamples, probs=0.25)
                   })
@

Note that the \texttt{NextBestMTD} class is quite flexible, because you can
specify a function \texttt{derive} that derives the next best dose from the
posterior MTD samples.

During the study, in order to derive the next best dose, we supply the generic
\texttt{nextBest} function with the rule, the maximum dose, the posterior
samples, the model and the data:

<<next-best-run>>=
doseRecommendation <- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)
@

The result is a list with two elements: \texttt{value} contains the numeric
value of the recommended next best dose, and \texttt{plot} contains a plot that
illustrates how the next best dose was computed. In this case we used the N-CRM
rule, therefore the plot gives the target-dosing and overdosing probabilities
together with the safety bar of 25\%, the maximum dose and the final
recommendation (the red triangle):

<<next-best-results, fig=TRUE>>=
doseRecommendation$value
print(doseRecommendation$plot)
@

\subsection{Cohort size rules}
\label{sec:increments-rules}

Similarly to the increments rules, you can define intervals in the dose space
and/or the DLT space to define the size of the cohorts. For example, let's
assume we want to have one patient only in the cohorts until we reach 30 mg or
the first DLT is encountered, and then proceed with three patients per cohort.

We start by creating the two separate rules, first for the dose range:

<<size-range>>=
mySize1 <- new("CohortSizeRange",
               intervals=c(0, 30, Inf),
               cohortSize=as.integer(c(1, 3)))
@

Then for the DLT range:

<<size-dlt>>=
mySize2 <- new("CohortSizeDLT",
               DLTintervals=c(0, 1, Inf),
               cohortSize=as.integer(c(1, 3)))
@

Finally we combine the two rules by taking the maximum number of patients of
both rules:

<<size-combined>>=
mySize <- maxSize(mySize1, mySize2)
@

The \texttt{CohortSize} rule is used by the \texttt{size} function, together
with the next dose and the current data, in order to determine the size of the
next cohort:

<<size-eval>>=
size(mySize,
     dose=doseRecommendation$value,
     data=data)
@

Because we have one DLT already, we would go for 3 patients for the next cohort.

Moreover, if you would like to have a constant cohort size, you can use the
following \texttt{CohortSizeConst} class, which we will use (with three
patients) for simplicity for the remainder of this vignette:

<<size-const>>=
mySize <- new("CohortSizeConst",
              size=3L)
@


\subsection{Stopping rules}
\label{sec:stopping-rules}

Stopping rules are often quite complex, and built from an and/or combination of
multiple parts. Therefore the \texttt{crmPack} implementation mirrors this, and
multiple atomic stopping rules can be combined easily. For example, let's assume
we would like to stop the trial if there are at least 3 cohorts and at least
50\% probability in the target toxicity interval $(20\%, 35\%)$, or the maximum
sample size of 20 patients has been reached. Then we start by creating the three
pieces the rule is composed of:

<<rules-bits>>=
myStopping1 <- new("StoppingMinCohorts",
                   nCohorts=3L)
myStopping2 <- new("StoppingMaxPatients",
                   nPatients=20L)
myStopping3 <- new("StoppingTargetProb",
                   target=c(0.2, 0.35),
                   prob=0.5)
@

Finally we combine these with the ``and'' operator \texttt{\&} and the ``or''
operator \verb-|-:

<<rules-compose>>=
myStopping <- (myStopping1 & myStopping3) | myStopping2
@

You can find a link to all implemented stopping rule parts in the help page
\texttt{Stopping-class}.

During the study, any (atomic or combined) stopping rule can be used by the
function \texttt{stopTrial} to determine if the rule has been fulfilled. For
example in our case:

<<rules-try>>=
stopTrial(stopping=myStopping, dose=doseRecommendation$value,
          samples=samples, model=model, data=data)
@

We receive here \texttt{FALSE}, which means that the stopping rule criteria have
not been met. The attribute \texttt{message} contains the textual results of the
atomic parts of the stopping rule. Here we can read that the probability for
target toxicity was just 31\% for the recommended dose 20 mg and therefore too
low, and also the maximum sample size has not been reached, therefore the trial
shall continue.

\section{Simulations}
\label{sec:simulations}

In order to run simulations, we first have to build a specific design, that
comprises a model, the escalation rules, starting data, a cohort size (currently
fixed during the trial) and a starting dose. It might seem strange at first
sight that we have to supply starting data to the design, but we will show below
that this makes sense. First, we use our \texttt{emptydata} object that only
contains the dose grid, and a cohorts of 3 patients, starting from 0.1 mg:

<<design-setup>>=
design <- new("Design",
              model=model,
              nextBest=myNextBest,
              stopping=myStopping,
              increments=myIncrements,
              cohortSize=mySize,
              data=emptydata,
              startingDose=3)
@

\subsection{Simulating from a true scenario}
\label{sec:simulating-from-true}

Next, we have to define a true scenario, from which the data should arise. In
this case, this only requires a function that computes the probability of DLT
given a dose. Here we use a specific case of the function contained in the model
space:

<<true-def, fig=TRUE>>=
## define the true function
myTruth <- function(dose)
{
    model@prob(dose, alpha0=-1, alpha1=4)
}

## plot it in the range of the dose grid
curve(myTruth(x), from=0, to=80, ylim=c(0, 1))
@

Now we can proceed to the simulations. We only generate 10 trial outcomes here
for illustration, for the actual study this should be increased of course to at
least 500:

<<run-sims>>=
set.seed(819)
time <- system.time(mySims <- simulate(design,
                                       truth=myTruth,
                                       args=NULL,
                                       nsim=10L,
                                       mcmcOptions=options,
                                       parallel=TRUE))[3]
time
@

We have wrapped the call to \texttt{simulate} in a \texttt{system.time} to
obtain the required time for the simulations (about \Sexpr{round(time)}~seconds
in this case). The argument \texttt{args} could contain additional arguments for
the \texttt{truth} function, which we did not require here and therefore set it
to \texttt{NULL}. Note that we also pass again the MCMC options object, because
during the trial simulations the MCMC routines are used. Finally, the argument
\texttt{parallel} can be used to enable the use of all processors of the
computer for running the simulations in parallel. This can yield a meaningful
speedup, especially for larger number of simulations.

As (almost) always, the result of this call is again an object with a class, in
this case \texttt{Simulations}:

<<sim-class>>=
class(mySims)
@

From the help page

<<sim-help>>=
help("Simulations-class")
@

we find the description of the slots of \texttt{mySims}. In particular, the
\texttt{data} slot contains the list of produced \texttt{Data} objects of the
simulated trials. Therefore, we can plot the course of e.g. the third simulated
trial as follows:

<<third-trial, fig=TRUE>>=
print(plot(mySims@data[[3]]))
@

The final dose for this trial was

<<third-dose>>=
mySims@doses[3]
@

and the stopping reason was

<<third-stop>>=
mySims@stopReasons[[3]]
@

Furthermore, with this object, we can apply two methods. First, we can plot it,
i.e. we can apply the plot method:

<<sim-plot, fig=TRUE>>=
library(grid)
grid.draw(plot(mySims))
@

The resulting plot shows on the top panel a summary of the trial trajectories.
Because of the low number of simulations here, we can essentially only see the
median trajectory. On the bottom, the proportions of doses tried, averaged over
the simulated trials, are shown. Note that you can select the plots by changing
the \texttt{type} argument of \texttt{plot}, which by default is \texttt{type =
  c("trajectory", "dosesTried")}.

Second, we can summarize the simulation results. Here again we have to supply a
true dose-toxicity function. We take the same (\texttt{myTruth}) as above:

<<sim-summary>>=
summary(mySims,
        truth=myTruth)
@

Note that the observed toxicity rate at dose most often selected (52 mg) is not
available, because no patients were actually treated at 52 mg during the
simulations. This means the MTD was selected based on the evidence from the data
at other dose levels.

Now we can also produce a plot of the summary results, which give a bit more
detail than the textual summary we have just seen:

<<sim-sum-plot, fig=TRUE>>=
simSum <- summary(mySims,
                  truth=myTruth)
grid.draw(plot(simSum))
@

The top left panel shows the distribution of the sample size across the
simulated trials. In this case all trials had 21 patients. The top right panel
shows the distribution of the final MTD estimate / recommended dose across the
simulated trials. The middle left panel shows the distribution across the
simulations of the DLT proportions observed in the patients dosed. Here we see
that not more than 14\% of the patients had DLTs in the simulated trials. The
middle right panel shows the distribution across simulations of the number of
patients treated above the target toxicity window (here we used the default from
20\% to 35\%). We see here that in all trials, none of the patients were treated
with too toxic doses. Finally, in the bottom panel we see a comparison of the
true dose-toxicity curve (black) with the estimated dose-toxicity curves,
averaged (continuous red line) across the trials and with 95\% credible interval
across the trials. Here we see a good correspondence of the truth and the
estimation.

If we find that e.g. the top right plot with the distribution of the final
selected doses is too small and shows not the right x-axis window, we can only
plot this one and add x-axis customization on top: (see the \texttt{ggplot2}
documentation for more on customizing)

<<sim-sum-plot2, fig=TRUE>>=
print(plot(simSum, type="doseSelected") +
      scale_x_continuous(breaks=40:60, limits=c(40, 60)))
@

\subsection{Predicting the future course of the trial}
\label{sec:pred-future-course}

By simulating parameters from their current posterior distribution instead of an
assumed truth, it is possible to generate trial simulations from the posterior
predictive distribution at any time point during the trial. This means that we
can predict the future course of the trial, given the current data. In our
illustrating example, this would work as follows.

The rationale of the \texttt{simulate} call is now that we specify as the
\texttt{truth} argument the \texttt{prob} function from our assumed model, which
has additional arguments (in our case \texttt{alpha0} and \texttt{alpha1}) on
top of the first argument \texttt{dose}:

<<explain-fut>>=
model@prob
@

For the simulations, these arguments are internally given by the values
contained in the data frame given to \texttt{simulate} as the \texttt{args}
argument. In our case, we want to supply the posterior samples of
\texttt{alpha0} and \texttt{alpha1} in this data frame. We take only 50 out of
the 1000 posterior samples in order to reduce the runtime for this example:

<<fut-samples>>=
postSamples <- as.data.frame(samples@data)[(1:20)*50, ]
postSamples
@

Therefore, each simulated trial will come from a posterior sample of our
estimated model, given all data so far.

Furthermore we have to make a new \texttt{Design} object that contains the
current data to start from, and the current recommended dose as the starting dose:

<<design-future>>=
nowDesign <- new("Design",
                 model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 ## use the current data:
                 data=data,
                 ## and the recommended dose as the starting dose:
                 startingDose=doseRecommendation$value)
@

Finally we can execute the simulations:

<<sim-future>>=
set.seed(901)
time <- system.time(futureSims <- simulate(## supply the new design here
                                           nowDesign,
                                           ## the truth is the assumed prob function
                                           truth=model@prob,
                                           ## further arguments are the
                                           ## posterior samples
                                           args=postSamples,
                                           ## do exactly so many simulations as
                                           ## we have samples
                                           nsim=nrow(postSamples),
                                           ## this remains the same:
                                           mcmcOptions=options,
                                           parallel=TRUE))[3]
time
@

And now, exactly in the same way as above for the operating characteristics
simulations, we can summarize the resulting predictive simulations, for example
show the predicted trajectories of doses:

<<sim-future-plot, fig=TRUE>>=
a <- plot(futureSims)
grid.draw(a)
@

In the summary, we do not need to look at the characteristics involving the true
dose-toxicity function, because in this case we are not intending to compare the
performance of our CRM relative to a truth:

<<sim-future-summary>>=
summary(futureSims,
        truth=myTruth)
@

We see here e.g. that the estimated number of patients overall is 19, so 11 more
than the current 8 patients are expected to be needed before finishing the
trial.

\bibliographystyle{plainnat}
\bibliography{example}

\end{document}



%%% Local Variables:
%%% mode: latex-math
%%% TeX-master: t
%%% coding: utf-8-unix
%%% ispell-local-dictionary: "english"
%%% End:
