{
    "contents" : "#####################################################################################\n## Author: Daniel Sabanes Bove [sabanesd *a*t* roche *.* com]\n## Project: Object-oriented implementation of CRM designs\n##\n## Time-stamp: <[Rules-class.R] by DSB Die 09/06/2015 21:28>\n##\n## Description:\n## Encapsulate the rules in formal classes.\n##\n## History:\n## 07/02/2014   file creation\n###################################################################################\n\n##' @include helpers.R\n{}\n\n## ============================================================\n\n## --------------------------------------------------\n## Virtual class for finding next best dose\n## --------------------------------------------------\n\n##' The virtual class for finding next best dose\n##'\n##' @seealso \\code{\\linkS4class{NextBestMTD}},\n##' \\code{\\linkS4class{NextBestNCRM}},\n##' \\code{\\linkS4class{NextBestDualEndpoint}},\n##' \\code{\\linkS4class{NextBestThreePlusThree}}\n##'\n##' @export\n##' @keywords classes\nsetClass(Class=\"NextBest\",\n         contains=list(\"VIRTUAL\"))\n\n\n## --------------------------------------------------\n## Next best dose based on MTD estimate\n## --------------------------------------------------\n\n##' The class with the input for finding the next best MTD estimate\n##'\n##' @slot target the target toxicity probability\n##' @slot derive the function which derives from the input, a vector of\n##' posterior MTD samples called \\code{mtdSamples}, the final next best MTD\n##' estimate.\n##'\n##' @export\n##' @keywords classes\n.NextBestMTD <-\n    setClass(Class=\"NextBestMTD\",\n             representation(target=\"numeric\",\n                            derive=\"function\"),\n             prototype(target=0.3,\n                       derive=\n                           function(mtdSamples){\n                               quantile(mtdSamples,\n                                        probs=0.3)}),\n             contains=list(\"NextBest\"),\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(is.probability(object@target,\n                                            bounds=FALSE),\n                             \"target must be probability > 0 and < 1\")\n                     o$check(identical(names(formals(object@derive)),\n                                       c(\"mtdSamples\")),\n                             \"derive must have as single argument 'mtdSamples'\")\n\n                     o$result()\n                 })\nvalidObject(.NextBestMTD())\n\n##' Initialization function for class \"NextBestMTD\"\n##'\n##' @param target see \\code{\\linkS4class{NextBestMTD}}\n##' @param derive see \\code{\\linkS4class{NextBestMTD}}\n##' @return the \\code{\\linkS4class{NextBestMTD}} object\n##'\n##' @export\n##' @keywords methods\nNextBestMTD <- function(target,\n                        derive)\n{\n    .NextBestMTD(target=target,\n                 derive=derive)\n}\n\n\n## --------------------------------------------------\n## Next best dose based on NCRM rule\n## --------------------------------------------------\n\n##' The class with the input for finding the next dose in target interval\n##'\n##' Note that to avoid numerical problems, the dose selection algorithm has been\n##' implemented as follows: First admissible doses are found, which are those\n##' with probability to fall in \\code{overdose} category being below\n##' \\code{maxOverdoseProb}. Next, within the admissible doses, the maximum\n##' probability to fall in the \\code{target} category is calculated. If that is\n##' above 5\\% (i.e., it is not just numerical error), then the corresponding\n##' dose is the next recommended dose. Otherwise, the highest admissible dose is\n##' the next recommended dose.\n##'\n##' @slot target the target toxicity interval (limits included)\n##' @slot overdose the overdose toxicity interval (lower limit excluded, upper\n##' limit included)\n##' @slot maxOverdoseProb maximum overdose probability that is allowed\n##'\n##' @export\n##' @keywords classes\n.NextBestNCRM <-\n    setClass(Class=\"NextBestNCRM\",\n             representation(target=\"numeric\",\n                            overdose=\"numeric\",\n                            maxOverdoseProb=\"numeric\"),\n             prototype(target=c(0.2, 0.35),\n                       overdose=c(0.35, 1),\n                       maxOverdoseProb=0.25),\n             contains=list(\"NextBest\"),\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(is.probRange(object@target),\n                             \"target has to be a probability range\")\n                     o$check(is.probRange(object@overdose),\n                             \"overdose has to be a probability range\")\n                     o$check(is.probability(object@maxOverdoseProb),\n                             \"maxOverdoseProb has to be a probability\")\n\n                     o$result()\n                 })\nvalidObject(.NextBestNCRM())\n\n\n##' Initialization function for \"NextBestNCRM\"\n##'\n##' @param target see \\code{\\linkS4class{NextBestNCRM}}\n##' @param overdose see \\code{\\linkS4class{NextBestNCRM}}\n##' @param maxOverdoseProb see \\code{\\linkS4class{NextBestNCRM}}\n##' @return the \\code{\\linkS4class{NextBestNCRM}} object\n##'\n##' @export\n##' @keywords methods\nNextBestNCRM <- function(target,\n                         overdose,\n                         maxOverdoseProb)\n{\n    .NextBestNCRM(target=target,\n                  overdose=overdose,\n                  maxOverdoseProb=maxOverdoseProb)\n}\n\n## --------------------------------------------------\n## Next best dose based on 3+3 rule\n## --------------------------------------------------\n\n##' The class with the input for finding the next dose in target interval\n##'\n##' Implements the classical 3+3 dose recommendation.\n##' No input is required, hence this class has no slots.\n##'\n##' @export\n##' @keywords classes\n.NextBestThreePlusThree <-\n    setClass(Class=\"NextBestThreePlusThree\",\n             contains=list(\"NextBest\"))\n\n##' Initialization function for \"NextBestThreePlusThree\"\n##'\n##' @return the \\code{\\linkS4class{NextBestThreePlusThree}} object\n##'\n##' @export\n##' @keywords methods\nNextBestThreePlusThree <- function()\n{\n    .NextBestThreePlusThree()\n}\n\n\n## --------------------------------------------------\n## Next best dose based on dual endpoint model\n## --------------------------------------------------\n\n##' The class with the input for finding the next dose\n##' based on the dual endpoint model\n##'\n##' This rule first excludes all doses that exceed the probability\n##' \\code{maxOverdoseProb} of having an overdose toxicity, as specified by the\n##' overdose interval \\code{overdose}. Then, it picks under the remaining\n##' admissible doses the one that maximizes the probability to be in the\n##' \\code{target} biomarker range, relative to the maximum biomarker level\n##' across the dose grid or relative to the Emax parameter in case a parametric\n##' model was selected (e.g. \\code{\\linkS4class{DualEndpointBeta}},\n##' \\code{\\linkS4class{DualEndpointEmax}}))\n##'\n##' @slot target the biomarker target range, relative to the maximum, that\n##' needs to be reached. For example, (0.8, 1.0) means we target a dose\n##' with at least 80\\% of maximum biomarker level. As an other example,\n##' (0.5, 0.8) would mean that we target a dose between 50\\% and 80\\% of\n##' the maximum biomarker level.\n##' @slot overdose the overdose toxicity interval (lower limit excluded, upper\n##' limit included)\n##' @slot maxOverdoseProb maximum overdose probability that is allowed\n##'\n##' @export\n##' @keywords classes\n.NextBestDualEndpoint <-\n    setClass(Class=\"NextBestDualEndpoint\",\n             representation(target=\"numeric\",\n                            overdose=\"numeric\",\n                            maxOverdoseProb=\"numeric\"),\n             prototype(target=c(0.9,1),\n                       overdose=c(0.35, 1),\n                       maxOverdoseProb=0.25),\n             contains=list(\"NextBest\"),\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(is.probRange(object@target),\n                             \"target has to be a probability range\")\n                     o$check(is.probRange(object@overdose),\n                             \"overdose has to be a probability range\")\n                     o$check(is.probability(object@maxOverdoseProb),\n                             \"maxOverdoseProb has to be a probability\")\n\n                     o$result()\n                 })\nvalidObject(.NextBestDualEndpoint())\n\n##' Initialization function for \"NextBestDualEndpoint\"\n##'\n##' @param target see \\code{\\linkS4class{NextBestDualEndpoint}}\n##' @param overdose see \\code{\\linkS4class{NextBestDualEndpoint}}\n##' @param maxOverdoseProb see \\code{\\linkS4class{NextBestDualEndpoint}}\n##' @return the \\code{\\linkS4class{NextBestDualEndpoint}} object\n##'\n##' @export\n##' @keywords methods\nNextBestDualEndpoint <- function(target,\n                                 overdose,\n                                 maxOverdoseProb)\n{\n    .NextBestDualEndpoint(target=target,\n                          overdose=overdose,\n                          maxOverdoseProb=maxOverdoseProb)\n}\n\n\n\n## ============================================================\n\n## --------------------------------------------------\n## Virtual class for increments control\n## --------------------------------------------------\n\n##' The virtual class for controlling increments\n##'\n##' @seealso \\code{\\linkS4class{IncrementsRelative}},\n##' \\code{\\linkS4class{IncrementsRelativeDLT}},\n##' \\code{\\linkS4class{IncrementsRelativeParts}}\n##'\n##' @export\n##' @keywords classes\nsetClass(Class=\"Increments\",\n         contains=list(\"VIRTUAL\"))\n\n\n## --------------------------------------------------\n## Increments control based on relative differences in intervals\n## --------------------------------------------------\n\n##' Increments control based on relative differences in intervals\n##'\n##' Note that \\code{intervals} is to be read as follows. If for example,\n##' we want to specify three intervals: First 0 to less than 50, second at least\n##' 50 up to less than 100 mg, and third at least 100 mg, then we specify\n##' \\code{intervals} to be \\code{c(0, 50, 100)}. That means, the right\n##' bound of the intervals are exclusive to the interval, and the last interval\n##' goes from the last value until infinity.\n##'\n##' @slot intervals a vector with the left bounds of the relevant intervals\n##' @slot increments a vector of the same length with the maximum allowable\n##' relative increments in the \\code{intervals}\n##'\n##' @export\n##' @keywords classes\n.IncrementsRelative <-\n    setClass(Class=\"IncrementsRelative\",\n             representation(intervals=\"numeric\",\n                            increments=\"numeric\"),\n             prototype(intervals=c(0, 2),\n                       increments=c(2, 1)),\n             contains=\"Increments\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(identical(length(object@increments),\n                                       length(object@intervals)),\n                             \"increments must have same length as intervals\")\n                     o$check(! is.unsorted(object@intervals, strictly=TRUE),\n                             \"intervals has to be sorted and have unique values\")\n\n                     o$result()\n                 })\nvalidObject(.IncrementsRelative())\n\n##' Initialization function for \"IncrementsRelative\"\n##'\n##' @param intervals see \\code{\\linkS4class{IncrementsRelative}}\n##' @param increments see \\code{\\linkS4class{IncrementsRelative}}\n##' @return the \\code{\\linkS4class{IncrementsRelative}} object\n##'\n##' @export\n##' @keywords methods\nIncrementsRelative <- function(intervals,\n                               increments)\n{\n    .IncrementsRelative(intervals=intervals,\n                        increments=increments)\n}\n\n## --------------------------------------------------\n## Increments control based on relative differences in intervals,\n## with special rules for part 1 and beginning of part 2\n## --------------------------------------------------\n\n##' Increments control based on relative differences in intervals,\n##' with special rules for part 1 and beginning of part 2\n##'\n##' Note that this only works in conjunction with \\code{\\linkS4class{DataParts}}\n##' objects. If the part 2 will just be started in the next cohort, then the\n##' next maximum dose will be either \\code{dltStart} (e.g. -1) shift of the last\n##' part 1 dose in case of a DLT in part 1, or \\code{cleanStart} shift (e.g. 0)\n##' in case of no DLTs in part 1. If part 1 will still be on in the next cohort,\n##' then the next dose level will be the next higher dose level in the\n##' \\code{part1Ladder} of the data object. If part 2 has been started before,\n##' the usual relative increment rules apply, see\n##' \\code{\\linkS4class{IncrementsRelative}}.\n##'\n##' @slot dltStart integer giving the dose level increment for starting part 2\n##' in case of a DLT in part 1\n##' @slot cleanStart integer giving the dose level increment for starting part 2\n##' in case of a DLT in part 1. If this is less or equal to 0, then the part 1\n##' ladder will be used to find the maximum next dose. If this is larger than 0,\n##' then the relative increment rules will be applied to find the next maximum\n##' dose level.\n##'\n##' @export\n##' @keywords classes\n.IncrementsRelativeParts <-\n    setClass(Class=\"IncrementsRelativeParts\",\n             representation(dltStart=\"integer\",\n                            cleanStart=\"integer\"),\n             prototype(dltStart=-1L,\n                       cleanStart=1L),\n             contains=\"IncrementsRelative\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(is.scalar(object@dltStart),\n                             \"dltStart must be scalar integer\")\n                     o$check(is.scalar(object@cleanStart),\n                             \"cleanStart must be scalar integer\")\n                     o$check(object@cleanStart >= object@dltStart,\n                             \"dltStart cannot be higher than cleanStart\")\n\n                     o$result()\n                 })\nvalidObject(.IncrementsRelativeParts())\n\n\n##' Initialization function for \"IncrementsRelativeParts\"\n##'\n##' @param dltStart see \\code{\\linkS4class{IncrementsRelativeParts}}\n##' @param cleanStart see \\code{\\linkS4class{IncrementsRelativeParts}}\n##' @param \\dots additional slots from \\code{\\linkS4class{IncrementsRelative}}\n##' @return the \\code{\\linkS4class{IncrementsRelativeParts}} object\n##'\n##' @export\n##' @keywords methods\nIncrementsRelativeParts <- function(dltStart,\n                                    cleanStart,\n                                    ...)\n{\n    .IncrementsRelativeParts(dltStart=safeInteger(dltStart),\n                             cleanStart=safeInteger(cleanStart),\n                             ...)\n}\n\n\n## --------------------------------------------------\n## Increments control based on relative differences in terms of DLTs\n## --------------------------------------------------\n\n##' Increments control based on relative differences in terms of DLTs\n##'\n##' Note that \\code{DLTintervals} is to be read as follows. If for example,\n##' we want to specify three intervals: First 0 DLTs, second 1 or 2 DLTs, and\n##' third at least 3 DLTs, then we specify\n##' \\code{DLTintervals} to be \\code{c(0, 1, 3)}. That means, the right\n##' bound of the intervals are exclusive to the interval -- the vector only\n##' gives the left bounds of the intervals. The last interval goes from 3 to\n##' infinity.\n##'\n##' @slot DLTintervals an integer vector with the left bounds of the relevant\n##' DLT intervals\n##' @slot increments a vector of the same length with the maximum allowable\n##' relative increments in the \\code{DLTintervals}\n##'\n##' @export\n##' @keywords classes\n.IncrementsRelativeDLT <-\n    setClass(Class=\"IncrementsRelativeDLT\",\n             representation(DLTintervals=\"integer\",\n                            increments=\"numeric\"),\n             prototype(DLTintervals=as.integer(c(0, 1)),\n                       increments=c(2, 1)),\n             contains=\"Increments\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(identical(length(object@increments),\n                                       length(object@DLTintervals)),\n                             \"increments must have same length as DLTintervals\")\n                     o$check(! is.unsorted(object@DLTintervals, strictly=TRUE),\n                             \"DLTintervals has to be sorted and have unique values\")\n                     o$check(all(object@DLTintervals >= 0),\n                             \"DLTintervals must only contain non-negative integers\")\n\n                     o$result()\n         })\nvalidObject(.IncrementsRelativeDLT())\n\n\n##' Initialization function for \"IncrementsRelativeDLT\"\n##'\n##' @param DLTintervals see \\code{\\linkS4class{IncrementsRelativeDLT}}\n##' @param increments see \\code{\\linkS4class{IncrementsRelativeDLT}}\n##' @return the \\code{\\linkS4class{IncrementsRelativeDLT}} object\n##'\n##' @export\n##' @keywords methods\nIncrementsRelativeDLT <- function(DLTintervals,\n                                  increments)\n{\n    .IncrementsRelativeDLT(DLTintervals=safeInteger(DLTintervals),\n                           increments=increments)\n}\n\n\n## ============================================================\n\n## --------------------------------------------------\n## Virtual class for stopping rules\n## --------------------------------------------------\n\n##' The virtual class for stopping rules\n##'\n##' @seealso \\code{\\linkS4class{StoppingList}},\n##' \\code{\\linkS4class{StoppingCohortsNearDose}},\n##' \\code{\\linkS4class{StoppingPatientsNearDose}},\n##' \\code{\\linkS4class{StoppingMinCohorts}},\n##' \\code{\\linkS4class{StoppingMinPatients}},\n##' \\code{\\linkS4class{StoppingTargetProb}}\n##' \\code{\\linkS4class{StoppingMTDdistribution}},\n##' \\code{\\linkS4class{StoppingTargetBiomarker}}\n##'\n##' @export\n##' @keywords classes\nsetClass(Class=\"Stopping\",\n         contains=list(\"VIRTUAL\"))\n\n\n## --------------------------------------------------\n## Stopping based on number of cohorts near to next best dose\n## --------------------------------------------------\n\n##' Stop based on number of cohorts near to next best dose\n##'\n##' @slot nCohorts number of required cohorts\n##' @slot percentage percentage (between 0 and 100) within the next best dose\n##' the cohorts must lie\n##'\n##' @keywords classes\n##' @export\n.StoppingCohortsNearDose <-\n    setClass(Class=\"StoppingCohortsNearDose\",\n             representation(nCohorts=\"integer\",\n                            percentage=\"numeric\"),\n             prototype(nCohorts=2L,\n                       percentage=50),\n             contains=\"Stopping\",\n             validity=function(object){\n                 o <- Validate()\n\n                 o$check((object@nCohorts > 0L) && is.scalar(object@nCohorts),\n                         \"nCohorts must be positive scalar\")\n                 o$check(is.probability(object@percentage / 100),\n                         \"percentage must be between 0 and 100\")\n\n                 o$result()\n             })\nvalidObject(.StoppingCohortsNearDose())\n\n##' Initialization function for \"StoppingCohortsNearDose\"\n##'\n##' @param nCohorts see \\code{\\linkS4class{StoppingCohortsNearDose}}\n##' @param percentage see \\code{\\linkS4class{StoppingCohortsNearDose}}\n##' @return the \\code{\\linkS4class{StoppingCohortsNearDose}} object\n##'\n##' @export\n##' @keywords methods\nStoppingCohortsNearDose <- function(nCohorts,\n                                    percentage)\n{\n    .StoppingCohortsNearDose(nCohorts=safeInteger(nCohorts),\n                             percentage=percentage)\n}\n## --------------------------------------------------\n## Stopping based on number of patients near to next best dose\n## --------------------------------------------------\n\n##' Stop based on number of patients near to next best dose\n##'\n##' @slot nPatients number of required patients\n##' @slot percentage percentage (between 0 and 100) within the next best dose\n##' the patients must lie\n##'\n##' @keywords classes\n##' @export\n.StoppingPatientsNearDose <-\n    setClass(Class=\"StoppingPatientsNearDose\",\n             representation(nPatients=\"integer\",\n                            percentage=\"numeric\"),\n             prototype(nPatients=10L,\n                       percentage=50),\n             contains=\"Stopping\",\n             validity=function(object){\n                 o <- Validate()\n\n                 o$check((object@nPatients > 0L) && is.scalar(object@nPatients),\n                         \"nPatients must be positive scalar\")\n                 o$check(is.probability(object@percentage / 100),\n                         \"percentage must be between 0 and 100\")\n\n                 o$result()\n             })\nvalidObject(.StoppingPatientsNearDose())\n\n\n##' Initialization function for \"StoppingPatientsNearDose\"\n##'\n##' @param nPatients see \\code{\\linkS4class{StoppingPatientsNearDose}}\n##' @param percentage see \\code{\\linkS4class{StoppingPatientsNearDose}}\n##' @return the \\code{\\linkS4class{StoppingPatientsNearDose}} object\n##'\n##' @export\n##' @keywords methods\nStoppingPatientsNearDose <- function(nPatients,\n                                     percentage)\n{\n    .StoppingPatientsNearDose(nPatients=safeInteger(nPatients),\n                              percentage=percentage)\n}\n\n\n## --------------------------------------------------\n## Stopping based on minimum number of cohorts\n## --------------------------------------------------\n\n##' Stop based on minimum number of cohorts\n##'\n##' @slot nCohorts minimum required number of cohorts\n##'\n##' @keywords classes\n##' @export\n.StoppingMinCohorts <-\n    setClass(Class=\"StoppingMinCohorts\",\n             representation(nCohorts=\"integer\"),\n             prototype(nCohorts=3L),\n             contains=\"Stopping\",\n             validity=function(object){\n                 o <- Validate()\n\n                 o$check((object@nCohorts > 0L) && is.scalar(object@nCohorts),\n                         \"nCohorts must be positive scalar\")\n\n                 o$result()\n             })\nvalidObject(.StoppingMinCohorts())\n\n\n\n##' Initialization function for \"StoppingMinCohorts\"\n##'\n##' @param nCohorts see \\code{\\linkS4class{StoppingMinCohorts}}\n##' @return the \\code{\\linkS4class{StoppingMinCohorts}} object\n##'\n##' @export\n##' @keywords methods\nStoppingMinCohorts <- function(nCohorts)\n{\n    .StoppingMinCohorts(nCohorts=safeInteger(nCohorts))\n}\n\n\n## --------------------------------------------------\n## Stopping based on minimum number of patients\n## --------------------------------------------------\n\n##' Stop based on minimum number of patients\n##'\n##' @slot nPatients minimum allowed number of patients\n##'\n##' @keywords classes\n##' @export\n.StoppingMinPatients <-\n    setClass(Class=\"StoppingMinPatients\",\n             representation(nPatients=\"integer\"),\n             prototype(nPatients=20L),\n             contains=\"Stopping\",\n             validity=function(object){\n                 o <- Validate()\n\n                 o$check((object@nPatients > 0L) && is.scalar(object@nPatients),\n                         \"nPatients must be positive scalar\")\n\n                 o$result()\n             })\nvalidObject(.StoppingMinPatients())\n\n##' Initialization function for \"StoppingMinPatients\"\n##'\n##' @param nPatients see \\code{\\linkS4class{StoppingMinPatients}}\n##' @return the \\code{\\linkS4class{StoppingMinPatients}} object\n##'\n##' @export\n##' @keywords methods\nStoppingMinPatients <- function(nPatients)\n{\n    .StoppingMinPatients(nPatients=safeInteger(nPatients))\n}\n\n\n## --------------------------------------------------\n## Stopping based on probability of target tox interval\n## --------------------------------------------------\n\n##' Stop based on probability of target tox interval\n##'\n##' @slot target the target toxicity interval, e.g. \\code{c(0.2, 0.35)}\n##' @slot prob required target toxicity probability (e.g. \\code{0.4})\n##' for reaching sufficient precision\n##'\n##' @keywords classes\n##' @export\n.StoppingTargetProb <-\n    setClass(Class=\"StoppingTargetProb\",\n             representation(target=\"numeric\",\n                            prob=\"numeric\"),\n             prototype(target=c(0.2, 0.35),\n                       prob=0.4),\n             contains=\"Stopping\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(is.probRange(object@target),\n                             \"target must be probability range\")\n                     o$check(is.probability(object@prob,\n                                            bounds=FALSE),\n                             \"prob must be probability > 0 and < 1\")\n\n                     o$result()\n                 })\nvalidObject(.StoppingTargetProb())\n\n\n##' Initialization function for \"StoppingTargetProb\"\n##'\n##' @param target see \\code{\\linkS4class{StoppingTargetProb}}\n##' @param prob see \\code{\\linkS4class{StoppingTargetProb}}\n##' @return the \\code{\\linkS4class{StoppingTargetProb}} object\n##'\n##' @export\n##' @keywords methods\nStoppingTargetProb <- function(target,\n                               prob)\n{\n    .StoppingTargetProb(target=target,\n                        prob=prob)\n}\n\n\n## --------------------------------------------------\n## Stopping based on MTD distribution\n## --------------------------------------------------\n\n##' Stop based on MTD distribution\n##'\n##' Has 90\\% probability above a threshold of 50\\% of the current\n##' MTD been reached? This class is used for this question.\n##'\n##' @slot target the target toxicity probability (e.g. 0.33) defining the MTD\n##' @slot thresh the threshold relative to the MTD (e.g. 0.5)\n##' @slot prob required probability (e.g. 0.9)\n##'\n##' @keywords classes\n##' @export\n.StoppingMTDdistribution <-\n    setClass(Class=\"StoppingMTDdistribution\",\n             representation(target=\"numeric\",\n                            thresh=\"numeric\",\n                            prob=\"numeric\"),\n             prototype(target=0.33,\n                       thresh=0.5,\n                       prob=0.9),\n             contains=\"Stopping\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(is.probability(object@target,\n                                            bounds=FALSE),\n                             \"target must be probability > 0 and < 1\")\n                     o$check(is.probability(object@thresh,\n                                            bounds=FALSE),\n                             \"thresh must be probability > 0 and < 1\")\n                     o$check(is.probability(object@prob,\n                                            bounds=FALSE),\n                             \"prob must be probability > 0 and < 1\")\n\n                     o$result()\n                 })\nvalidObject(.StoppingMTDdistribution())\n\n\n##' Initialization function for \"StoppingMTDdistribution\"\n##'\n##' @param target see \\code{\\linkS4class{StoppingMTDdistribution}}\n##' @param thresh see \\code{\\linkS4class{StoppingMTDdistribution}}\n##' @param prob see \\code{\\linkS4class{StoppingMTDdistribution}}\n##' @return the \\code{\\linkS4class{StoppingMTDdistribution}} object\n##'\n##' @export\n##' @keywords methods\nStoppingMTDdistribution <- function(target,\n                                    thresh,\n                                    prob)\n{\n    .StoppingMTDdistribution(target=target,\n                             thresh=thresh,\n                             prob=prob)\n}\n\n\n## --------------------------------------------------\n## Stopping based on probability of target biomarker\n## --------------------------------------------------\n\n##' Stop based on probability of target biomarker\n##'\n##' @slot target the biomarker target range, relative to the maximum, that\n##' needs to be reached. So this must be a probability range (1 is allowed here)\n##' @slot prob required target probability for reaching sufficient precision\n##'\n##' @keywords classes\n##' @export\n.StoppingTargetBiomarker <-\n    setClass(Class=\"StoppingTargetBiomarker\",\n             representation(target=\"numeric\",\n                            prob=\"numeric\"),\n             prototype(target=c(0.9, 1),\n                       prob=0.3),\n             contains=\"Stopping\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(is.probRange(object@target),\n                             \"target has to be a probability range\")\n                     o$check(is.probability(object@prob,\n                                            bounds=FALSE),\n                             \"prob must be probability > 0 and < 1\")\n\n                     o$result()\n                 })\nvalidObject(.StoppingTargetBiomarker())\n\n\n##' Initialization function for \"StoppingTargetBiomarker\"\n##'\n##' @param target see \\code{\\linkS4class{StoppingTargetBiomarker}}\n##' @param prob see \\code{\\linkS4class{StoppingTargetBiomarker}}\n##' @return the \\code{\\linkS4class{StoppingTargetBiomarker}} object\n##'\n##' @export\n##' @keywords methods\nStoppingTargetBiomarker <- function(target,\n                                    prob)\n{\n    .StoppingTargetBiomarker(target=target,\n                             prob=prob)\n}\n\n## --------------------------------------------------\n## Stopping based on multiple stopping rules\n## --------------------------------------------------\n\n##' Stop based on multiple stopping rules\n##'\n##' This class can be used to combine multiple stopping rules.\n##'\n##' \\code{stopList} contains all stopping rules, which are again objects of\n##' class \\code{\\linkS4class{Stopping}}, and the \\code{summary} is a function\n##' taking a logical vector of the size of \\code{stopList} and returning a\n##' single logical value. For example, if the function \\code{all} is given as\n##' \\code{summary} function, then this means that all stopping rules must be\n##' fulfilled in order that the result of this rule is to stop.\n##'\n##' @slot stopList list of stopping rules\n##' @slot summary the summary function to combine the results of the stopping\n##' rules into a single result\n##'\n##' @keywords classes\n##' @export\n.StoppingList <-\n    setClass(Class=\"StoppingList\",\n             representation(stopList=\"list\",\n                            summary=\"function\"),\n             prototype(stopList=\n                           list(StoppingMinPatients(50),\n                                StoppingMinCohorts(5)),\n                       summary=all),\n             contains=\"Stopping\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(all(sapply(object@stopList, is, \"Stopping\")),\n                             \"all stopList elements have to Stopping objects\")\n                     testRes <- object@summary(rep(c(TRUE, FALSE),\n                                                   length.out=length(object@stopList)))\n                     o$check(is.bool(testRes),\n                             \"summary function must return a boolean value\")\n\n                     o$result()\n                 })\nvalidObject(.StoppingList())\n\n\n##' Initialization function for \"StoppingList\"\n##'\n##' @param stopList see \\code{\\linkS4class{StoppingList}}\n##' @param summary see \\code{\\linkS4class{StoppingList}}\n##' @return the \\code{\\linkS4class{StoppingList}} object\n##'\n##' @export\n##' @keywords methods\nStoppingList <- function(stopList,\n                         summary)\n{\n    .StoppingList(stopList=stopList,\n                  summary=summary)\n}\n\n\n## --------------------------------------------------\n## Stopping based on fulfillment of all multiple stopping rules\n## --------------------------------------------------\n\n##' Stop based on fullfillment of all multiple stopping rules\n##'\n##' This class can be used to combine multiple stopping rules with an AND\n##' operator.\n##'\n##' \\code{stopList} contains all stopping rules, which are again objects of\n##' class \\code{\\linkS4class{Stopping}}. All stopping rules must be fulfilled in\n##' order that the result of this rule is to stop.\n##'\n##' @slot stopList list of stopping rules\n##'\n##' @keywords classes\n##' @export\n.StoppingAll <-\n    setClass(Class=\"StoppingAll\",\n             representation(stopList=\"list\"),\n             prototype(stopList=\n                           list(StoppingMinPatients(50),\n                                StoppingMinCohorts(5))),\n             contains=\"Stopping\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(all(sapply(object@stopList, is, \"Stopping\")),\n                             \"all stopList elements have to Stopping objects\")\n\n                     o$result()\n                 })\nvalidObject(.StoppingAll())\n\n\n##' Initialization function for \"StoppingAll\"\n##'\n##' @param stopList see \\code{\\linkS4class{StoppingAll}}\n##' @return the \\code{\\linkS4class{StoppingAll}} object\n##'\n##' @export\n##' @keywords methods\nStoppingAll <- function(stopList)\n{\n    .StoppingAll(stopList=stopList)\n}\n\n\n## --------------------------------------------------\n## Stopping based on fulfillment of any stopping rule\n## --------------------------------------------------\n\n##' Stop based on fullfillment of any stopping rule\n##'\n##' This class can be used to combine multiple stopping rules with an OR\n##' operator.\n##'\n##' \\code{stopList} contains all stopping rules, which are again objects of\n##' class \\code{\\linkS4class{Stopping}}. Any of these rules must be fulfilled in\n##' order that the result of this rule is to stop.\n##'\n##' @slot stopList list of stopping rules\n##'\n##' @keywords classes\n##' @export\n.StoppingAny <-\n    setClass(Class=\"StoppingAny\",\n             representation(stopList=\"list\"),\n             prototype(stopList=\n                           list(StoppingMinPatients(50),\n                                StoppingMinCohorts(5))),\n             contains=\"Stopping\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(all(sapply(object@stopList, is, \"Stopping\")),\n                             \"all stopList elements have to Stopping objects\")\n\n                     o$result()\n                 })\nvalidObject(.StoppingAny())\n\n\n##' Initialization function for \"StoppingAny\"\n##'\n##' @param stopList see \\code{\\linkS4class{StoppingAny}}\n##' @return the \\code{\\linkS4class{StoppingAny}} object\n##'\n##' @export\n##' @keywords methods\nStoppingAny <- function(stopList)\n{\n    .StoppingAny(stopList=stopList)\n}\n\n\n\n## ============================================================\n\n\n\n## --------------------------------------------------\n## Virtual class for cohort sizes\n## --------------------------------------------------\n\n##' The virtual class for cohort sizes\n##'\n##' @seealso \\code{\\linkS4class{CohortSizeMax}},\n##' \\code{\\linkS4class{CohortSizeMin}},\n##' \\code{\\linkS4class{CohortSizeRange}},\n##' \\code{\\linkS4class{CohortSizeDLT}},\n##' \\code{\\linkS4class{CohortSizeConst}},\n##' \\code{\\linkS4class{CohortSizeParts}}\n##'\n##' @export\n##' @keywords classes\nsetClass(Class=\"CohortSize\",\n         contains=list(\"VIRTUAL\"))\n\n\n## --------------------------------------------------\n## Cohort size based on dose range\n## --------------------------------------------------\n\n##' Cohort size based on dose range\n##'\n##' @slot intervals a vector with the left bounds of the relevant dose intervals\n##' @slot cohortSize an integer vector of the same length with the cohort\n##' sizes in the \\code{intervals}\n##'\n##' @export\n##' @keywords classes\n.CohortSizeRange <-\n    setClass(Class=\"CohortSizeRange\",\n             representation(intervals=\"numeric\",\n                            cohortSize=\"integer\"),\n             prototype(intervals=c(0, 20),\n                       cohortSize=as.integer(c(1L, 3L))),\n             contains=\"CohortSize\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(identical(length(object@cohortSize),\n                                       length(object@intervals)),\n                             \"cohortSize must have same length as intervals\")\n                     o$check(all(object@cohortSize > 0),\n                             \"cohortSize must only contain positive integers\")\n                     o$check(! is.unsorted(object@intervals, strictly=TRUE),\n                             \"intervals has to be sorted and have unique values\")\n\n                     o$result()\n                 })\nvalidObject(.CohortSizeRange())\n\n##' Initialization function for \"CohortSizeRange\"\n##'\n##' @param intervals see \\code{\\linkS4class{CohortSizeRange}}\n##' @param cohortSize see \\code{\\linkS4class{CohortSizeRange}}\n##' @return the \\code{\\linkS4class{CohortSizeRange}} object\n##'\n##' @export\n##' @keywords methods\nCohortSizeRange <- function(intervals,\n                            cohortSize)\n{\n    .CohortSizeRange(intervals=intervals,\n                     cohortSize=safeInteger(cohortSize))\n}\n\n## --------------------------------------------------\n## Cohort size based on number of DLTs\n## --------------------------------------------------\n\n##' Cohort size based on number of DLTs\n##'\n##' @slot DLTintervals an integer vector with the left bounds of the relevant\n##' DLT intervals\n##' @slot cohortSize an integer vector of the same length with the cohort\n##' sizes in the \\code{DLTintervals}\n##'\n##' @export\n##' @keywords classes\n.CohortSizeDLT <-\n    setClass(Class=\"CohortSizeDLT\",\n             representation(DLTintervals=\"integer\",\n                            cohortSize=\"integer\"),\n             prototype(DLTintervals=as.integer(c(0, 1)),\n                       cohortSize=as.integer(c(1, 3))),\n             contains=\"CohortSize\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(identical(length(object@cohortSize),\n                                       length(object@DLTintervals)),\n                             \"cohortSize must have same length as DLTintervals\")\n                     o$check(all(object@cohortSize > 0),\n                             \"cohortSize must only contain positive integers\")\n                     o$check(! is.unsorted(object@DLTintervals, strictly=TRUE),\n                             \"DLTintervals has to be sorted and have unique values\")\n                     o$check(all(object@DLTintervals >= 0),\n                             \"DLTintervals must only contain non-negative integers\")\n\n                     o$result()\n                 })\nvalidObject(.CohortSizeDLT())\n\n##' Initialization function for \"CohortSizeDLT\"\n##'\n##' @param DLTintervals see \\code{\\linkS4class{CohortSizeDLT}}\n##' @param cohortSize see \\code{\\linkS4class{CohortSizeDLT}}\n##' @return the \\code{\\linkS4class{CohortSizeDLT}} object\n##'\n##' @export\n##' @keywords methods\nCohortSizeDLT <- function(DLTintervals,\n                          cohortSize)\n{\n    .CohortSizeDLT(DLTintervals=safeInteger(DLTintervals),\n                   cohortSize=safeInteger(cohortSize))\n}\n\n\n## --------------------------------------------------\n## Constant cohort size\n## --------------------------------------------------\n\n##' Constant cohort size\n##'\n##' This class is used when the cohort size should be kept constant.\n##'\n##' @slot size the constant integer size\n##'\n##' @keywords classes\n##' @export\n.CohortSizeConst <-\n    setClass(Class=\"CohortSizeConst\",\n             representation(size=\"integer\"),\n             prototype(size=3L),\n             contains=\"CohortSize\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(is.scalar(object@size) && (object@size > 0),\n                             \"size needs to be positive scalar\")\n\n                     o$result()\n                 })\nvalidObject(.CohortSizeConst())\n\n##' Initialization function for \"CohortSizeConst\"\n##'\n##' @param size see \\code{\\linkS4class{CohortSizeConst}}\n##' @return the \\code{\\linkS4class{CohortSizeConst}} object\n##'\n##' @export\n##' @keywords methods\nCohortSizeConst <- function(size)\n{\n    .CohortSizeConst(size=safeInteger(size))\n}\n\n\n\n## --------------------------------------------------\n## Cohort size based on the parts\n## --------------------------------------------------\n\n##' Cohort size based on the parts\n##'\n##' This class is used when the cohort size should change for the second part of\n##' the dose escalation. Only works in conjunction with\n##' \\code{\\linkS4class{DataParts}} objects.\n##'\n##' @slot sizes the two sizes for part 1 and part 2\n##'\n##' @keywords classes\n##' @export\n.CohortSizeParts <-\n    setClass(Class=\"CohortSizeParts\",\n             representation(sizes=\"integer\"),\n             prototype(sizes=as.integer(c(1, 3))),\n             contains=\"CohortSize\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(all(object@sizes > 0),\n                             \"the cohort sizes need to be positive\")\n                     o$check(identical(length(object@sizes), 2L),\n                             \"2 elements required in sizes\")\n\n                     o$result()\n                 })\nvalidObject(.CohortSizeParts())\n\n##' Initialization function for \"CohortSizeParts\"\n##'\n##' @param sizes see \\code{\\linkS4class{CohortSizeParts}}\n##' @return the \\code{\\linkS4class{CohortSizeParts}} object\n##' @export\n##'\n##' @keywords methods\nCohortSizeParts <- function(sizes)\n{\n    .CohortSizeParts(sizes=safeInteger(sizes))\n}\n\n\n## --------------------------------------------------\n## Size based on maximum of multiple cohort size rules\n## --------------------------------------------------\n\n##' Size based on maximum of multiple cohort size rules\n##'\n##' This class can be used to combine multiple cohort size rules with the MAX\n##' operation.\n##'\n##' \\code{cohortSizeList} contains all cohort size rules, which are again\n##' objects of class \\code{\\linkS4class{CohortSize}}. The maximum of these\n##' individual cohort sizes is taken to give the final cohort size.\n##'\n##' @slot cohortSizeList list of cohort size rules\n##'\n##' @keywords classes\n##' @export\n.CohortSizeMax <-\n    setClass(Class=\"CohortSizeMax\",\n             representation(cohortSizeList=\"list\"),\n             prototype(cohortSizeList=\n                           list(CohortSizeRange(intervals=c(0, 30),\n                                                cohortSize=c(1, 3)),\n                                CohortSizeDLT(DLTintervals=c(0, 1),\n                                              cohortSize=c(1, 3)))),\n             contains=\"CohortSize\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(all(sapply(object@cohortSizeList, is,\n                                        \"CohortSize\")),\n                             \"all cohortSizeList elements have to be CohortSize objects\")\n\n                     o$result()\n                 })\nvalidObject(.CohortSizeMax())\n\n\n##' Initialization function for \"CohortSizeMax\"\n##'\n##' @param cohortSizeList see \\code{\\linkS4class{CohortSizeMax}}\n##' @return the \\code{\\linkS4class{CohortSizeMax}} object\n##'\n##' @export\n##' @keywords methods\nCohortSizeMax <- function(cohortSizeList)\n{\n    .CohortSizeMax(cohortSizeList=cohortSizeList)\n}\n\n\n## --------------------------------------------------\n## Size based on minimum of multiple cohort size rules\n## --------------------------------------------------\n\n##' Size based on minimum of multiple cohort size rules\n##'\n##' This class can be used to combine multiple cohort size rules with the MIN\n##' operation.\n##'\n##' \\code{cohortSizeList} contains all cohort size rules, which are again\n##' objects of class \\code{\\linkS4class{CohortSize}}. The minimum of these\n##' individual cohort sizes is taken to give the final cohort size.\n##'\n##' @slot cohortSizeList list of cohort size rules\n##'\n##' @keywords classes\n##' @export\n.CohortSizeMin <-\n    setClass(Class=\"CohortSizeMin\",\n             representation(cohortSizeList=\"list\"),\n             prototype(cohortSizeList=\n                           list(CohortSizeRange(intervals=c(0, 30),\n                                                cohortSize=c(1, 3)),\n                                CohortSizeDLT(DLTintervals=c(0, 1),\n                                              cohortSize=c(1, 3)))),\n             contains=\"CohortSize\",\n             validity=\n                 function(object){\n                     o <- Validate()\n\n                     o$check(all(sapply(object@cohortSizeList, is,\n                                        \"CohortSize\")),\n                             \"all cohortSizeList elements have to be CohortSize objects\")\n\n                     o$result()\n                 })\nvalidObject(.CohortSizeMin())\n\n\n##' Initialization function for \"CohortSizeMin\"\n##'\n##' @param cohortSizeList see \\code{\\linkS4class{CohortSizeMin}}\n##' @return the \\code{\\linkS4class{CohortSizeMin}} object\n##'\n##' @export\n##' @keywords methods\nCohortSizeMin <- function(cohortSizeList)\n{\n    .CohortSizeMin(cohortSizeList=cohortSizeList)\n}\n\n\n\n## ============================================================\n",
    "created" : 1436865821449.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "185532208",
    "id" : "1AD575FB",
    "lastKnownWriteTime" : 1436258382,
    "path" : "C:/R/Rdev/crmpack/R/Rules-class.R",
    "project_path" : "R/Rules-class.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}