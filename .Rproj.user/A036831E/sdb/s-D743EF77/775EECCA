{
    "contents" : "#####################################################################################\n## Author: Daniel Sabanes Bove [sabanesd *a*t* roche *.* com]\n## Project: Object-oriented implementation of CRM designs\n##\n## Time-stamp: <[Rules-methods.R] by DSB Die 09/06/2015 21:29>\n##\n## Description:\n## Encapsulate the rule functions in formal methods.\n##\n## History:\n## 07/02/2014   file creation\n###################################################################################\n\n##' @include Model-methods.R\n##' @include Samples-class.R\n##' @include Rules-class.R\n{}\n\n## ============================================================\n\n## --------------------------------------------------\n## Find out what is the next best dose\n## --------------------------------------------------\n\n\n##' Find the next best dose\n##'\n##' Compute the recommended next best dose.\n##'\n##' This function outputs the next best dose recommendation based on the\n##' corresponding rule \\code{nextBest}, the posterior \\code{samples} from the\n##' \\code{model} and the underlying \\code{data}.\n##'\n##' @param nextBest The rule, an object of class \\code{\\linkS4class{NextBest}}\n##' @param doselimit The maximum allowed next dose. If this is an empty (length\n##' 0) vector, then no dose limit will be applied in the course of dose\n##' recommendation calculation, and a corresponding warning is given.\n##' @param samples the \\code{\\linkS4class{Samples}} object\n##' @param model The model input, an object of class \\code{\\linkS4class{Model}}\n##' @param data The data input, an object of class \\code{\\linkS4class{Data}}\n##' @param \\dots possible additional arguments without method dispatch\n##' @return a list with the next best dose (element \\code{value})\n##' on the grid defined in \\code{data}, and a plot depicting this recommendation\n##' (element \\code{plot})\n##'\n##' @export\n##' @keywords methods\nsetGeneric(\"nextBest\",\n           def=\n               function(nextBest, doselimit, samples, model, data, ...){\n\n                   ## there should be no default method,\n                   ## therefore just forward to next method!\n                   standardGeneric(\"nextBest\")\n               },\n           valueClass=\"list\")\n\n## --------------------------------------------------\n## The MTD method\n## --------------------------------------------------\n\n##' @describeIn nextBest Find the next best dose based on the MTD rule\n##'\n##' @importFrom ggplot2 ggplot geom_density xlab ylab xlim aes geom_vline\n##' geom_text\nsetMethod(\"nextBest\",\n          signature=\n          signature(nextBest=\"NextBestMTD\",\n                    doselimit=\"numeric\",\n                    samples=\"Samples\",\n                    model=\"Model\",\n                    data=\"Data\"),\n          def=\n              function(nextBest, doselimit, samples, model, data, ...){\n\n                  if(identical(length(doselimit), 0L))\n                  {\n                      warning(\"doselimit is empty, therefore no dose limit will be applied\")\n                  }\n\n              ## First, generate the MTD samples.\n              mtdSamples <- dose(prob=nextBest@target,\n                                 model,\n                                 samples)\n\n              ## then derive the next best dose\n              mtdEstimate <- nextBest@derive(mtdSamples=mtdSamples)\n\n              ## be sure which doses are ok with respect to maximum\n              ## possible dose - if one was specified\n              dosesOK <-\n                  if(length(doselimit))\n                      which(data@doseGrid <= doselimit)\n                  else\n                      seq_along(data@doseGrid)\n\n              ## but now, round to the next possible grid point\n              index <- which.min(abs(data@doseGrid[dosesOK] - mtdEstimate))\n              ret <- data@doseGrid[dosesOK][index]\n\n              ## produce plot\n              plot1 <- ggplot() +\n                      geom_density(data=\n                                   data.frame(x=mtdSamples),\n                                   aes(x=x),\n                                   fill = \"grey50\", colour = \"grey50\") +\n                          xlab(\"MTD\") + ylab(\"Posterior density\") +\n                              xlim(range(data@doseGrid))\n\n              plot1 <- plot1 +\n                  geom_vline(xintercept=mtdEstimate, colour=\"black\", lwd=1.1) +\n                      geom_text(data=\n                                data.frame(x=mtdEstimate),\n                                aes(x, 0,\n                                    label = \"Est\", hjust=+1, vjust = +1),\n                                colour=\"black\")\n\n              if(length(doselimit))\n              {\n                  plot1 <- plot1 +\n                      geom_vline(xintercept=doselimit, colour=\"red\", lwd=1.1) +\n                          geom_text(data=\n                                        data.frame(x=doselimit),\n                                    aes(x, 0,\n                                        label = \"Max\", hjust = +1, vjust = +1),\n                                    colour=\"red\")\n              }\n\n              plot1 <- plot1 +\n                  geom_vline(xintercept=ret, colour=\"blue\", lwd=1.1) +\n                      geom_text(data=\n                                data.frame(x=ret),\n                                aes(x, 0,\n                                    label = \"Next\", hjust = 0, vjust = +1),\n                                colour=\"blue\")\n\n              ## return next best dose and plot\n              return(list(value=ret,\n                          plot=plot1))\n          })\n\n## --------------------------------------------------\n## The NCRM method\n## --------------------------------------------------\n\n##' @describeIn nextBest Find the next best dose based on the NCRM method\n##'\n##' @importFrom ggplot2 ggplot geom_bar xlab ylab ylim aes geom_vline\n##' geom_hline geom_point\n##' @importFrom gridExtra arrangeGrob\nsetMethod(\"nextBest\",\n          signature=\n          signature(nextBest=\"NextBestNCRM\",\n                    doselimit=\"numeric\",\n                    samples=\"Samples\",\n                    model=\"Model\",\n                    data=\"Data\"),\n          def=\n              function(nextBest, doselimit, samples, model, data, ...){\n\n                  if(identical(length(doselimit), 0L))\n                  {\n                      warning(\"doselimit is empty, therefore no dose limit will be applied\")\n                  }\n\n              ## first we have to get samples from the dose-tox\n              ## curve at the dose grid points.\n              probSamples <- matrix(nrow=sampleSize(samples@options),\n                                    ncol=data@nGrid)\n\n              ## evaluate the probs, for all samples.\n              for(i in seq_len(data@nGrid))\n              {\n                  ## Now we want to evaluate for the\n                  ## following dose:\n                  probSamples[, i] <- prob(dose=data@doseGrid[i],\n                                           model,\n                                           samples)\n              }\n\n              ## Now compute probabilities to be in target and\n              ## overdose tox interval\n              probTarget <-\n                  colMeans((probSamples >= nextBest@target[1]) &\n                           (probSamples <= nextBest@target[2]))\n\n              probOverdose <-\n                  colMeans((probSamples > nextBest@overdose[1]) &\n                           (probSamples <= nextBest@overdose[2]))\n\n              ## which doses are eligible after accounting\n              ## for maximum possible dose and  discarding overdoses?\n              dosesBelowLimit <-\n                  if(length(doselimit))\n                      (data@doseGrid <= doselimit)\n                  else\n                      rep(TRUE, length(data@doseGrid))\n\n              dosesOK <- which(dosesBelowLimit &\n                               (probOverdose < nextBest@maxOverdoseProb))\n\n              ## check if there are doses that are OK\n              if(length(dosesOK))\n              {\n                  ## what is the recommended dose level?\n\n                  ## if maximum target probability is higher than some numerical\n                  ## threshold, then take that level, otherwise stick to the\n                  ## maximum level that is OK:\n                  doseLevel <-\n                      if(max(probTarget[dosesOK]) > 0.05)\n                      {\n                          which.max(probTarget[dosesOK])\n                      } else {\n                          which.max(data@doseGrid[dosesOK])\n                      }\n\n                  ret <- data@doseGrid[dosesOK][doseLevel]\n              } else {\n                  ## if none of the doses is OK:\n                  doseLevel <- NA\n                  ret <- NA\n              }\n\n              ## produce plot\n\n              ## first for the target probability\n              plot1 <- ggplot() +\n                  geom_bar(data=\n                           data.frame(x=data@doseGrid,\n                                      y=probTarget * 100),\n                           aes(x=x, y=y),\n                           stat=\"identity\",\n                           position=\"identity\",\n                           width=1,\n                           colour=\"darkgreen\",\n                           fill=\"darkgreen\") +\n                               xlab(\"Dose\") +\n                                   ylab(paste(\"Target probability [%]\")) +\n                                       ylim(c(0, 100))\n\n              if(length(doselimit))\n              {\n                  plot1 <- plot1 +\n                      geom_vline(xintercept=doselimit,\n                                 lwd=1.1,\n                                 lty=2,\n                                 colour=\"black\")\n              }\n\n              if(length(dosesOK))\n              {\n                  plot1 <- plot1 +\n                      geom_vline(xintercept=data@doseGrid[max(dosesOK)],\n                                 lwd=1.1,\n                                 lty=2,\n                                 colour=\"red\")\n\n                  plot1 <- plot1 +\n                      geom_point(data=\n                                 data.frame(x=ret,\n                                            y=probTarget[dosesOK][doseLevel] *\n                                            100 + 0.03),\n                                 aes(x=x, y=y),\n                                 size=3,\n                                 pch=25,\n                                 col=\"red\",\n                                 bg=\"red\")\n              }\n\n              ## second for the overdosing probability\n              plot2 <- ggplot() +\n                  geom_bar(data=\n                           data.frame(x=data@doseGrid,\n                                      y=probOverdose * 100),\n                           aes(x=x, y=y),\n                           stat=\"identity\",\n                           position=\"identity\",\n                           width=1,\n                           colour=\"red\",\n                           fill=\"red\") +\n                               xlab(\"Dose\") +\n                                   ylab(\"Overdose probability [%]\") +\n                                       ylim(c(0, 100))\n\n              plot2 <- plot2 +\n                  geom_hline(yintercept=nextBest@maxOverdoseProb * 100,\n                             lwd=1.1,\n                             lty=2,\n                             colour=\"black\")\n\n              ## now plot them below each other\n              plotJoint <- gridExtra::arrangeGrob(plot1, plot2, nrow=2)\n\n              ## return value and plot\n              return(list(value=ret,\n                          plot=plotJoint))\n          })\n\n\n##' @describeIn nextBest Find the next best dose based on the NCRM method when\n##' two parts trial is used\nsetMethod(\"nextBest\",\n          signature=\n          signature(nextBest=\"NextBestNCRM\",\n                    doselimit=\"numeric\",\n                    samples=\"Samples\",\n                    model=\"Model\",\n                    data=\"DataParts\"),\n          def=\n              function(nextBest, doselimit, samples, model, data, ...){\n\n              ## exception when we are in part I or about to start part II!\n              if(all(data@part == 1L))\n              {\n                  ## here we will always propose the highest possible dose\n                  ## (assuming that the dose limit came from reasonable\n                  ## increments rule, i.e. inrementsRelativeParts)\n                  if(identical(length(doselimit), 0L))\n                  {\n                      stop(\"doselimit needs to be given for Part I\")\n                  }\n\n                  return(list(value=doselimit,\n                              plot=NULL))\n              } else {\n                  ## otherwise we will just do the standard thing\n                  callNextMethod(nextBest, doselimit, samples, model, data, ...)\n              }\n          })\n\n\n## --------------------------------------------------\n## The 3+3 method\n## --------------------------------------------------\n\n##' @describeIn nextBest Find the next best dose based on the 3+3 method\nsetMethod(\"nextBest\",\n          signature=\n          signature(nextBest=\"NextBestThreePlusThree\",\n                    doselimit=\"missing\",\n                    samples=\"missing\",\n                    model=\"missing\",\n                    data=\"Data\"),\n          def=\n          function(nextBest, doselimit, samples, model, data, ...){\n\n              ## split the DLTs into the dose level groups\n              dltSplit <- split(data@y,\n                                factor(data@x,\n                                       levels=data@doseGrid))\n\n              ## number of patients and number of DLTs per dose level group\n              nPatients <- sapply(dltSplit, length)\n              nDLTs <- sapply(dltSplit, sum)\n\n              ## what was the last dose level tested?\n              lastLevel <- tail(data@xLevel, 1)\n\n              ## if there are less than 1/3 DLTs at that level\n              if(nDLTs[lastLevel]/nPatients[lastLevel] < 1/3)\n              {\n                  ## we could escalate, unless this is the highest\n                  ## level or the higher level was tried already\n                  ## (in which case it was not safe)\n                  if((lastLevel == length(data@doseGrid)) ||\n                     (nPatients[lastLevel+1] > 0))\n                  {\n                      nextLevel <- lastLevel\n                  } else {\n                      nextLevel <- lastLevel + 1\n                  }\n              } else if(nDLTs[lastLevel]/nPatients[lastLevel] > 1/3) {\n                  ## rate here is too high, therefore deescalate\n                  nextLevel <- lastLevel - 1\n              } else {\n                  ## otherwise: rate is 1/3 == 2/6,\n                  ## then it depends on the number of patients:\n                  ## if more than 3, then deescalate, otherwise stay.\n                  nextLevel <-\n                      if(nPatients[lastLevel] > 3)\n                          lastLevel - 1\n                      else\n                          lastLevel\n              }\n\n              ## do we stop here? only if we have no MTD\n              ## or the next level has been tried enough (more than\n              ## three patients already)\n              stopHere <-\n                  if(nextLevel == 0)\n                  {\n                      TRUE\n                  } else {\n                      nPatients[nextLevel] > 3\n                  }\n\n              ## return value and plot\n              return(list(value=\n                          if(nextLevel == 0) NA else data@doseGrid[nextLevel],\n                          stopHere=stopHere))\n          })\n\n\n\n## --------------------------------------------------\n## The method for the dual endpoint model\n## --------------------------------------------------\n\n##' @describeIn nextBest Find the next best dose based on the dual endpoint\n##' model\n##'\n##' @importFrom ggplot2 ggplot geom_bar xlab ylab ylim aes geom_vline\n##' geom_hline geom_point\n##' @importFrom gridExtra arrangeGrob\nsetMethod(\"nextBest\",\n          signature=\n          signature(nextBest=\"NextBestDualEndpoint\",\n                    doselimit=\"numeric\",\n                    samples=\"Samples\",\n                    model=\"DualEndpoint\",\n                    data=\"Data\"),\n          def=\n          function(nextBest, doselimit, samples, model, data, ...){\n\n              if(identical(length(doselimit), 0L))\n                  {\n                      warning(\"doselimit is empty, therefore no dose limit will be applied\")\n                  }\n\n              ## get the biomarker level samples\n              ## at the dose grid points.\n              biomLevelSamples <- matrix(nrow=sampleSize(samples@options),\n                                         ncol=data@nGrid)\n\n              ## evaluate the biomLevels, for all samples.\n              for(i in seq_len(data@nGrid))\n              {\n                  ## Now we want to evaluate for the\n                  ## following dose:\n                  biomLevelSamples[, i] <- biomLevel(dose=data@doseGrid[i],\n                                                     xLevel=i,\n                                                     model,\n                                                     samples)\n              }\n              ## biomLevelSamples <- samples@data$betaW\n\n\n              ## now get samples from the dose-tox\n              ## curve at the dose grid points.\n              probSamples <- matrix(nrow=sampleSize(samples@options),\n                                    ncol=data@nGrid)\n\n              ## evaluate the probs, for all samples.\n              for(i in seq_len(data@nGrid))\n              {\n                  ## Now we want to evaluate for the\n                  ## following dose:\n                  probSamples[, i] <- prob(dose=data@doseGrid[i],\n                                           model,\n                                           samples)\n              }\n\n              # If there is an 'Emax' parameter, target biomarker level will\n              # be relative to 'Emax', otherwise will be relative to the\n              # maximum biomarker level achieved in the given dose range.\n              if(\"Emax\" %in% names(samples@data)){\n\n                  ## For each sample, look which dose is maximizing the\n                  ## simultaneous probability to be in the target biomarker\n                  ## range and below overdose toxicity\n                  probTarget <- numeric(ncol(biomLevelSamples))\n                  probTarget <- sapply(seq(1,ncol(biomLevelSamples)),\n                                       function(x){\n                                           sum(biomLevelSamples[, x] >= nextBest@target[1]*samples@data$Emax &\n                                               biomLevelSamples[, x] <= nextBest@target[2]*samples@data$Emax &\n                                               probSamples[, x] <= nextBest@overdose[1]) / nrow(biomLevelSamples)\n                                       })\n              }else{\n\n                  ## For each sample, look which was the minimum dose giving\n                  ## relative target level\n                  targetIndex <- apply(biomLevelSamples, 1L,\n                                       function(x){\n                                           rnx <- range(x)\n                                           min(which((x >= nextBest@target[1] * diff(rnx) + rnx[1]) &\n                                                     (x <= nextBest@target[2] * diff(rnx) + rnx[1] + 1e-15))\n                                              )\n                                       })\n\n                  probTarget <- numeric(ncol(biomLevelSamples))\n                  tab <- table(targetIndex)\n                  probTarget[as.numeric(names(tab))] <- tab\n                  probTarget <- probTarget / nrow(biomLevelSamples)\n              }\n\n              ## Now compute probabilities to be in\n              ## overdose tox interval\n              probOverdose <-\n                  colMeans((probSamples > nextBest@overdose[1]) &\n                           (probSamples <= nextBest@overdose[2]))\n\n              ## which doses are eligible after accounting\n              ## for maximum possible dose and discarding overdoses?\n              dosesBelowLimit <-\n                  if(length(doselimit))\n                      (data@doseGrid <= doselimit)\n                  else\n                      rep(TRUE, length(data@doseGrid))\n\n              dosesOK <- which(dosesBelowLimit &\n                               (probOverdose < nextBest@maxOverdoseProb))\n\n              ## check if there are doses that are OK\n              if(length(dosesOK))\n              {\n                  ## what is the recommended dose level?\n\n                  ## if maximum target probability is higher than some numerical\n                  ## threshold, then take that level, otherwise stick to the\n                  ## maximum level that is OK:\n                  doseLevel <-\n                      if(max(probTarget[dosesOK]) > 0.05)\n                      {\n                          which.max(probTarget[dosesOK])\n                      } else {\n                          which.max(data@doseGrid[dosesOK])\n                      }\n\n                  ret <- data@doseGrid[dosesOK][doseLevel]\n              } else {\n                  ## if none of the doses is OK:\n                  doseLevel <- NA\n                  ret <- NA\n              }\n\n              ## produce plot\n\n              ## first for the target probability\n              plot1 <- ggplot() +\n                  geom_bar(data=\n                           data.frame(x=data@doseGrid,\n                                      y=probTarget * 100),\n                           aes(x=x, y=y),\n                           stat=\"identity\",\n                           position=\"identity\",\n                           width=1,\n                           colour=\"darkgreen\",\n                           fill=\"darkgreen\") +\n                               xlab(\"Dose\") +\n                                   ylab(paste(\"Target probability [%]\")) +\n                                       ylim(c(0, 100))\n\n              if(length(doselimit))\n              {\n                  plot1 <- plot1 +\n                      geom_vline(xintercept=doselimit,\n                                 lwd=1.1,\n                                 lty=2,\n                                 colour=\"black\")\n              }\n\n              if(length(dosesOK))\n              {\n                  plot1 <- plot1 +\n                      geom_vline(xintercept=data@doseGrid[max(dosesOK)],\n                                 lwd=1.1,\n                                 lty=2,\n                                 colour=\"red\")\n\n                  plot1 <- plot1 +\n                      geom_point(data=\n                                 data.frame(x=ret,\n                                            y=probTarget[dosesOK][doseLevel] *\n                                            100 + 0.03),\n                                 aes(x=x, y=y),\n                                 size=3,\n                                 pch=25,\n                                 col=\"red\",\n                                 bg=\"red\")\n              }\n\n              ## second for the overdosing probability\n              plot2 <- ggplot() +\n                  geom_bar(data=\n                           data.frame(x=data@doseGrid,\n                                      y=probOverdose * 100),\n                           aes(x=x, y=y),\n                           stat=\"identity\",\n                           position=\"identity\",\n                           width=1,\n                           colour=\"red\",\n                           fill=\"red\") +\n                               xlab(\"Dose\") +\n                                   ylab(\"Overdose probability [%]\") +\n                                       ylim(c(0, 100))\n\n              plot2 <- plot2 +\n                  geom_hline(yintercept=nextBest@maxOverdoseProb * 100,\n                             lwd=1.1,\n                             lty=2,\n                             colour=\"black\")\n\n              ## now plot them below each other\n              plotJoint <- gridExtra::arrangeGrob(plot1, plot2, nrow=2)\n\n              ## return value and plot\n              return(list(value=ret,\n                          plot=plotJoint))\n          })\n\n\n\n## ============================================================\n\n\n## --------------------------------------------------\n## Determine the maximum possible next dose\n## --------------------------------------------------\n\n##' Determine the maximum possible next dose\n##'\n##' Determine the upper limit of the next dose based on the increments rule.\n##'\n##' This function outputs the maximum possible next dose, based on the\n##' corresponding rule \\code{increments} and the \\code{data}.\n##'\n##' @param increments The rule, an object of class\n##' \\code{\\linkS4class{Increments}}\n##' @param data The data input, an object of class \\code{\\linkS4class{Data}}\n##' @param \\dots further arguments\n##' @return the maximum possible next dose\n##'\n##' @export\n##' @keywords methods\nsetGeneric(\"maxDose\",\n           def=\n           function(increments, data, ...){\n               ## there should be no default method,\n               ## therefore just forward to next method!\n               standardGeneric(\"maxDose\")\n           },\n           valueClass=\"numeric\")\n\n\n## --------------------------------------------------\n## The maximum allowable relative increments in intervals method\n## --------------------------------------------------\n\n##' @describeIn maxDose Determine the maximum possible next dose based on\n##' relative increments\nsetMethod(\"maxDose\",\n          signature=\n          signature(increments=\"IncrementsRelative\",\n                    data=\"Data\"),\n          def=\n          function(increments, data, ...){\n              ## determine what was the last dose\n              lastDose <- tail(data@x, 1)\n\n              ## determine in which interval this dose was\n              lastInterval <-\n                  findInterval(x=lastDose,\n                               vec=increments@intervals)\n\n              ## so the maximum next dose is\n              ret <-\n                  (1 + increments@increments[lastInterval]) *\n                      lastDose\n\n              return(ret)\n          })\n\n\n## --------------------------------------------------\n## The maximum allowable relative increments, with special rules for\n## part 1 and beginning of part 2, method method\n## --------------------------------------------------\n\n##' @describeIn maxDose Determine the maximum possible next dose based on\n##' relative increments and part 1 and 2\nsetMethod(\"maxDose\",\n          signature=\n          signature(increments=\"IncrementsRelativeParts\",\n                    data=\"DataParts\"),\n          def=\n          function(increments, data, ...){\n\n              ## determine if there are already cohorts\n              ## belonging to part 2:\n              alreadyInPart2 <- any(data@part == 2L)\n\n              ## if so, we just call the next higher method\n              if(alreadyInPart2)\n              {\n                  callNextMethod(increments, data, ...)\n              } else {\n                  ## otherwise we have special rules.\n\n                  ## what dose level (index) has the highest dose\n                  ## so far?\n                  lastDoseLevel <- match(max(data@x),\n                                         data@part1Ladder)\n\n                  ## determine the next maximum dose\n                  ret <-\n                      if(data@nextPart == 1L)\n                      {\n                          ## here the next cohort will still be in part 1.\n                          ## Therefore we just make one step on the part 1 ladder:\n                          data@part1Ladder[lastDoseLevel + 1L]\n                      } else {\n                          ## the next cohort will start part 2.\n\n                          ## if there was a DLT so far:\n                          if(any(data@y == 1L))\n                          {\n                              data@part1Ladder[lastDoseLevel + increments@dltStart]\n                          } else {\n                              ## otherwise\n                              if(increments@cleanStart > 0)\n                              {\n                                  ## if we want to start part 2 higher than\n                                  ## the last part 1 dose, use usual increments\n                                  callNextMethod(increments, data, ...)\n                              } else {\n                                  ## otherwise\n                                  data@part1Ladder[lastDoseLevel + increments@cleanStart]\n                              }\n                          }\n                      }\n\n                  return(ret)\n              }\n          })\n\n\n## --------------------------------------------------\n## The maximum allowable relative increments in terms of DLTs\n## --------------------------------------------------\n\n##' @describeIn maxDose Determine the maximum possible next dose based on\n##' relative increments determined by DLTs so far\nsetMethod(\"maxDose\",\n          signature=\n          signature(increments=\"IncrementsRelativeDLT\",\n                    data=\"Data\"),\n          def=\n          function(increments, data, ...){\n              ## determine what was the last dose\n              lastDose <- tail(data@x, 1)\n\n              ## determine how many DLTs have occurred so far\n              dltHappened <- sum(data@y)\n\n              ## determine in which interval this is\n              interval <-\n                  findInterval(x=dltHappened,\n                               vec=increments@DLTintervals)\n\n              ## so the maximum next dose is\n              ret <-\n                  (1 + increments@increments[interval]) *\n                      lastDose\n\n              return(ret)\n          })\n\n\n## ============================================================\n\n## --------------------------------------------------\n## \"AND\" combination of stopping rules\n## --------------------------------------------------\n\n##' The method combining two atomic stopping rules\n##'\n##' @param e1 First \\code{\\linkS4class{Stopping}} object\n##' @param e2 Second \\code{\\linkS4class{Stopping}} object\n##' @return The \\code{\\linkS4class{StoppingAll}} object\n##'\n##' @keywords methods\nsetMethod(\"&\",\n          signature(e1=\"Stopping\",\n                    e2=\"Stopping\"),\n          def=\n          function(e1, e2){\n              StoppingAll(list(e1, e2))\n          })\n\n##' The method combining a stopping list and an atomic\n##'\n##' @param e1 \\code{\\linkS4class{StoppingAll}} object\n##' @param e2 \\code{\\linkS4class{Stopping}} object\n##' @return The modified \\code{\\linkS4class{StoppingAll}} object\n##'\n##' @keywords methods\nsetMethod(\"&\",\n          signature(e1=\"StoppingAll\",\n                    e2=\"Stopping\"),\n          def=\n          function(e1, e2){\n              e1@stopList <- c(e1@stopList,\n                               e2)\n              return(e1)\n          })\n\n##' The method combining an atomic and a stopping list\n##'\n##' @param e1 \\code{\\linkS4class{Stopping}} object\n##' @param e2 \\code{\\linkS4class{StoppingAll}} object\n##' @return The modified \\code{\\linkS4class{StoppingAll}} object\n##'\n##' @keywords methods\nsetMethod(\"&\",\n          signature(e1=\"Stopping\",\n                    e2=\"StoppingAll\"),\n          def=\n          function(e1, e2){\n              e2@stopList <- c(e1,\n                               e2@stopList)\n              return(e2)\n          })\n\n## --------------------------------------------------\n## \"OR\" combination of stopping rules\n## --------------------------------------------------\n\n##' The method combining two atomic stopping rules\n##'\n##' @param e1 First \\code{\\linkS4class{Stopping}} object\n##' @param e2 Second \\code{\\linkS4class{Stopping}} object\n##' @return The \\code{\\linkS4class{StoppingAny}} object\n##'\n##' @aliases |,Stopping,Stopping-method\n##' @name or-Stopping-Stopping\n##' @keywords methods\nsetMethod(\"|\",\n          signature(e1=\"Stopping\",\n                    e2=\"Stopping\"),\n          def=\n          function(e1, e2){\n              StoppingAny(list(e1, e2))\n          })\n\n##' The method combining a stopping list and an atomic\n##'\n##' @param e1 \\code{\\linkS4class{StoppingAny}} object\n##' @param e2 \\code{\\linkS4class{Stopping}} object\n##' @return The modified \\code{\\linkS4class{StoppingAny}} object\n##'\n##' @aliases |,StoppingAny,Stopping-method\n##' @name or-Stopping-StoppingAny\n##' @keywords methods\nsetMethod(\"|\",\n          signature(e1=\"StoppingAny\",\n                    e2=\"Stopping\"),\n          def=\n          function(e1, e2){\n              e1@stopList <- c(e1@stopList,\n                               e2)\n              return(e1)\n          })\n\n##' The method combining an atomic and a stopping list\n##'\n##' @param e1 \\code{\\linkS4class{Stopping}} object\n##' @param e2 \\code{\\linkS4class{StoppingAny}} object\n##' @return The modified \\code{\\linkS4class{StoppingAny}} object\n##'\n##' @aliases |,Stopping,StoppingAny-method\n##' @name or-StoppingAny-Stopping\n##' @keywords methods\nsetMethod(\"|\",\n          signature(e1=\"Stopping\",\n                    e2=\"StoppingAny\"),\n          def=\n          function(e1, e2){\n              e2@stopList <- c(e1,\n                               e2@stopList)\n              return(e2)\n          })\n\n\n\n## --------------------------------------------------\n## Stop the trial?\n## --------------------------------------------------\n\n##' Stop the trial?\n##'\n##' This function returns whether to stop the trial.\n##'\n##' @param stopping The rule, an object of class\n##' \\code{\\linkS4class{Stopping}}\n##' @param dose the recommended next best dose\n##' @param samples the \\code{\\linkS4class{Samples}} object\n##' @param model The model input, an object of class \\code{\\linkS4class{Model}}\n##' @param data The data input, an object of class \\code{\\linkS4class{Data}}\n##' @param \\dots additional arguments\n##'\n##' @return logical value: \\code{TRUE} if the trial can be stopped, \\code{FALSE}\n##' otherwise. It should have an attribute \\code{message} which gives the reason\n##' for the decision.\n##'\n##' @export\n##' @keywords methods\nsetGeneric(\"stopTrial\",\n           def=\n           function(stopping, dose, samples, model, data, ...){\n               ## if the recommended next dose is NA,\n               ## stop in any case.\n               if(is.na(dose))\n               {\n                   return(structure(TRUE,\n                                    message=\"Recommended next best dose is NA\"))\n               }\n\n               ## there should be no default method,\n               ## therefore just forward to next method!\n               standardGeneric(\"stopTrial\")\n           },\n           valueClass=\"logical\")\n\n\n## --------------------------------------------------\n## Stopping based on multiple stopping rules\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on multiple stopping rules\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingList\",\n                    dose=\"ANY\",\n                    samples=\"ANY\",\n                    model=\"ANY\",\n                    data=\"ANY\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## evaluate the individual stopping rules\n              ## in the list\n              individualResults <-\n                  lapply(stopping@stopList,\n                         stopTrial,\n                         dose=dose,\n                         samples=samples,\n                         model=model,\n                         data=data,\n                         ...)\n\n              ## summarize to obtain overall result\n              overallResult <- stopping@summary(as.logical(individualResults))\n\n              ## retrieve individual text messages,\n              ## but let them in the list structure\n              overallText <- lapply(individualResults, attr, \"message\")\n\n              return(structure(overallResult,\n                               message=overallText))\n          })\n\n## --------------------------------------------------\n## Stopping based on fulfillment of all multiple stopping rules\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on fulfillment of all multiple stopping\n##' rules\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingAll\",\n                    dose=\"ANY\",\n                    samples=\"ANY\",\n                    model=\"ANY\",\n                    data=\"ANY\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## evaluate the individual stopping rules\n              ## in the list\n              individualResults <-\n                  lapply(stopping@stopList,\n                         stopTrial,\n                         dose=dose,\n                         samples=samples,\n                         model=model,\n                         data=data,\n                         ...)\n\n              ## summarize to obtain overall result\n              overallResult <- all(as.logical(individualResults))\n\n              ## retrieve individual text messages,\n              ## but let them in the list structure\n              overallText <- lapply(individualResults, attr, \"message\")\n\n              return(structure(overallResult,\n                               message=overallText))\n          })\n\n\n## --------------------------------------------------\n## Stopping based on fulfillment of any stopping rule\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on fulfillment of any stopping rule\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingAny\",\n                    dose=\"ANY\",\n                    samples=\"ANY\",\n                    model=\"ANY\",\n                    data=\"ANY\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## evaluate the individual stopping rules\n              ## in the list\n              individualResults <-\n                  lapply(stopping@stopList,\n                         stopTrial,\n                         dose=dose,\n                         samples=samples,\n                         model=model,\n                         data=data,\n                         ...)\n\n              ## summarize to obtain overall result\n              overallResult <- any(as.logical(individualResults))\n\n              ## retrieve individual text messages,\n              ## but let them in the list structure\n              overallText <- lapply(individualResults, attr, \"message\")\n\n              return(structure(overallResult,\n                               message=overallText))\n          })\n\n\n\n\n## --------------------------------------------------\n## Stopping based on number of cohorts near to next best dose\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on number of cohorts near to next best dose\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingCohortsNearDose\",\n                    dose=\"numeric\",\n                    samples=\"ANY\",\n                    model=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## determine the range where the cohorts must lie in\n              lower <- (100 - stopping@percentage) / 100 * dose\n              upper <- (100 + stopping@percentage) / 100 * dose\n\n              ## which patients lie there?\n              indexPatients <- which((data@x >= lower) & (data@x <= upper))\n\n              ## how many cohorts?\n              nCohorts <- length(unique(data@cohort[indexPatients]))\n\n              ## so can we stop?\n              doStop <- nCohorts >= stopping@nCohorts\n\n              ## generate message\n              text <- paste(nCohorts,\n                            \" cohorts lie within \",\n                            stopping@percentage,\n                            \"% of the next best dose \",\n                            dose,\n                            \". This \",\n                            ifelse(doStop, \"reached\", \"is below\"),\n                            \" the required \",\n                            stopping@nCohorts,\n                            \" cohorts\",\n                            sep=\"\")\n\n              ## return both\n              return(structure(doStop,\n                               message=text))\n          })\n\n\n## --------------------------------------------------\n## Stopping based on number of patients near to next best dose\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on number of patients near to next best\n##' dose\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingPatientsNearDose\",\n                    dose=\"numeric\",\n                    samples=\"ANY\",\n                    model=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## determine the range where the cohorts must lie in\n              lower <- (100 - stopping@percentage) / 100 * dose\n              upper <- (100 + stopping@percentage) / 100 * dose\n\n              ## how many patients lie there?\n              nPatients <- sum((data@x >= lower) & (data@x <= upper))\n\n              ## so can we stop?\n              doStop <- nPatients >= stopping@nPatients\n\n              ## generate message\n              text <- paste(nPatients,\n                            \" patients lie within \",\n                            stopping@percentage,\n                            \"% of the next best dose \",\n                            dose,\n                            \". This \",\n                            ifelse(doStop, \"reached\", \"is below\"),\n                            \" the required \",\n                            stopping@nPatients,\n                            \" patients\",\n                            sep=\"\")\n\n              ## return both\n              return(structure(doStop,\n                               message=text))\n          })\n\n## --------------------------------------------------\n## Stopping based on minimum number of cohorts\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on minimum number of cohorts\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingMinCohorts\",\n                    dose=\"ANY\",\n                    samples=\"ANY\",\n                    model=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## determine number of cohorts\n              nCohorts <- length(unique(data@cohort))\n\n              ## so can we stop?\n              doStop <- nCohorts >= stopping@nCohorts\n\n              ## generate message\n              text <-\n                  paste(\"Number of cohorts is\",\n                        nCohorts,\n                        \"and thus\",\n                        ifelse(doStop, \"reached\", \"below\"),\n                        \"the prespecified minimum number\",\n                        stopping@nCohorts)\n\n              ## return both\n              return(structure(doStop,\n                               message=text))\n          })\n\n## --------------------------------------------------\n## Stopping based on minimum number of patients\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on minimum number of patients\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingMinPatients\",\n                    dose=\"ANY\",\n                    samples=\"ANY\",\n                    model=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## so can we stop?\n              doStop <- data@nObs >= stopping@nPatients\n\n              ## generate message\n              text <-\n                  paste(\"Number of patients is\",\n                        data@nObs,\n                        \"and thus\",\n                        ifelse(doStop, \"reached\", \"below\"),\n                        \"the prespecified minimum number\",\n                        stopping@nPatients)\n\n              ## return both\n              return(structure(doStop,\n                               message=text))\n          })\n\n\n## --------------------------------------------------\n## Stopping based on probability of target tox interval\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on probability of target tox interval\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingTargetProb\",\n                    dose=\"numeric\",\n                    samples=\"Samples\",\n                    model=\"Model\",\n                    data=\"ANY\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## first we have to get samples from the dose-tox\n              ## curve at the dose.\n              probSamples <- prob(dose=dose,\n                                  model,\n                                  samples)\n\n              ## Now compute probability to be in target interval\n              probTarget <-\n                  mean((probSamples >= stopping@target[1]) &\n                       (probSamples <= stopping@target[2]))\n\n              ## so can we stop?\n              doStop <- probTarget >= stopping@prob\n\n              ## generate message\n              text <-\n                  paste(\"Probability for target toxicity is\",\n                        round(probTarget * 100),\n                        \"% for dose\",\n                        dose,\n                        \"and thus\",\n                        ifelse(doStop, \"above\", \"below\"),\n                        \"the required\",\n                        round(stopping@prob * 100),\n                        \"%\")\n\n              ## return both\n              return(structure(doStop,\n                               message=text))\n          })\n\n\n## --------------------------------------------------\n## Stopping based on MTD distribution\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on MTD distribution\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingMTDdistribution\",\n                    dose=\"numeric\",\n                    samples=\"Samples\",\n                    model=\"Model\",\n                    data=\"ANY\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## First, generate the MTD samples.\n\n              ## add prior data and samples to the\n              ## function environment so that they\n              ## can be used.\n              mtdSamples <- dose(prob=stopping@target,\n                                 model,\n                                 samples)\n\n              ## what is the absolute threshold?\n              absThresh <- stopping@thresh * dose\n\n              ## what is the probability to be above this dose?\n              prob <- mean(mtdSamples > absThresh)\n\n              ## so can we stop?\n              doStop <- prob >= stopping@prob\n\n              ## generate message\n              text <-\n                  paste(\"Probability of MTD above\",\n                        round(stopping@thresh * 100),\n                        \"% of current dose\",\n                        dose,\n                        \"is\",\n                        round(prob * 100),\n                        \"% and thus\",\n                        ifelse(doStop, \"above\", \"below\"),\n                        \"the required\",\n                        round(stopping@prob * 100),\n                        \"%\")\n\n              ## return both\n              return(structure(doStop,\n                               message=text))\n          })\n\n\n## --------------------------------------------------\n## Stopping based on probability of targeting biomarker\n## --------------------------------------------------\n\n##' @describeIn stopTrial Stop based on probability of targeting biomarker\nsetMethod(\"stopTrial\",\n          signature=\n          signature(stopping=\"StoppingTargetBiomarker\",\n                    dose=\"numeric\",\n                    samples=\"Samples\",\n                    model=\"DualEndpoint\",\n                    data=\"ANY\"),\n          def=\n          function(stopping, dose, samples, model, data, ...){\n              ## compute the target biomarker prob at this dose\n\n              ## get the biomarker level samples\n              ## at the dose grid points.\n              biomLevelSamples <- matrix(nrow=sampleSize(samples@options),\n                                         ncol=data@nGrid)\n\n              ## evaluate the biomLevels, for all samples.\n              for(i in seq_len(data@nGrid))\n              {\n                  ## Now we want to evaluate for the\n                  ## following dose:\n                  biomLevelSamples[, i] <- biomLevel(dose=data@doseGrid[i],\n                                                     xLevel=i,\n                                                     model,\n                                                     samples)\n              }\n\n              ## If there is an 'Emax' parameter, target biomarker level will\n              ## be relative to 'Emax', otherwise will be relative to the\n              ## maximum biomarker level achieved in the given dose range.\n              if(\"Emax\" %in% names(samples@data)){\n\n                  ## For each sample, look which dose is maximizing the\n                  ## simultaneous probability to be in the target biomarker\n                  ## range and below overdose toxicity\n                  probTarget <- numeric(ncol(biomLevelSamples))\n                  probTarget <- sapply(seq(1,ncol(biomLevelSamples)),\n                                       function(x){\n                                           sum(biomLevelSamples[, x] >= stopping@target[1]*samples@data$Emax &\n                                               biomLevelSamples[, x] <= stopping@target[2]*samples@data$Emax &\n                                               probSamples[, x] <= stopping@overdose[1]) / nrow(biomLevelSamples)\n                                       })\n              }else{\n\n                  ## For each sample, look which was the minimum dose giving\n                  ## relative target level\n                  targetIndex <- apply(biomLevelSamples, 1L,\n                                       function(x){\n                                           rnx <- range(x)\n                                           min(which((x >= stopping@target[1] * diff(rnx) + rnx[1]) &\n                                                     (x <= stopping@target[2] * diff(rnx) + rnx[1] + 1e-15))\n                                              )\n                                       })\n\n                  probTarget <- numeric(ncol(biomLevelSamples))\n                  tab <- table(targetIndex)\n                  probTarget[as.numeric(names(tab))] <- tab\n                  probTarget <- probTarget / nrow(biomLevelSamples)\n              }\n\n              ## so for this dose we have:\n              probTarget <- probTarget[which(data@doseGrid == dose)]\n\n              ## so can we stop?\n              doStop <- probTarget >= stopping@prob\n\n              ## generate message\n              text <-\n                  paste(\"Probability for target biomarker is\",\n                        round(probTarget * 100),\n                        \"% for dose\",\n                        dose,\n                        \"and thus\",\n                        ifelse(doStop, \"above\", \"below\"),\n                        \"the required\",\n                        round(stopping@prob * 100),\n                        \"%\")\n\n              ## return both\n              return(structure(doStop,\n                               message=text))\n          })\n\n## ============================================================\n\n## --------------------------------------------------\n## \"MAX\" combination of cohort size rules\n## --------------------------------------------------\n\n##' \"MAX\" combination of cohort size rules\n##'\n##' This function combines cohort size rules by taking\n##' the maximum of all sizes.\n##'\n##' @param \\dots Objects of class \\code{\\linkS4class{CohortSize}}\n##' @return the combination as an object of class\n##' \\code{\\linkS4class{CohortSizeMax}}\n##'\n##' @seealso \\code{\\link{minSize}}\n##' @export\n##' @keywords methods\nsetGeneric(\"maxSize\",\n           def=\n           function(...){\n               ## there should be no default method,\n               ## therefore just forward to next method!\n               standardGeneric(\"maxSize\")\n           },\n           valueClass=\"CohortSizeMax\")\n\n##' @describeIn maxSize The method combining cohort size rules by taking maximum\nsetMethod(\"maxSize\",\n          \"CohortSize\",\n          def=\n          function(...){\n              CohortSizeMax(list(...))\n          })\n\n## --------------------------------------------------\n## \"MIN\" combination of cohort size rules\n## --------------------------------------------------\n\n##' \"MIN\" combination of cohort size rules\n##'\n##' This function combines cohort size rules by taking\n##' the minimum of all sizes.\n##'\n##' @param \\dots Objects of class \\code{\\linkS4class{CohortSize}}\n##' @return the combination as an object of class\n##' \\code{\\linkS4class{CohortSizeMin}}\n##'\n##' @seealso \\code{\\link{maxSize}}\n##' @export\n##' @keywords methods\nsetGeneric(\"minSize\",\n           def=\n           function(...){\n               ## there should be no default method,\n               ## therefore just forward to next method!\n               standardGeneric(\"minSize\")\n           },\n           valueClass=\"CohortSizeMin\")\n\n##' @describeIn minSize The method combining cohort size rules by taking minimum\nsetMethod(\"minSize\",\n          \"CohortSize\",\n          def=\n          function(...){\n              CohortSizeMin(list(...))\n          })\n\n\n## --------------------------------------------------\n## Determine the size of the next cohort\n## --------------------------------------------------\n\n##' Determine the size of the next cohort\n##'\n##' This function determines the size of the next cohort.\n##'\n##' @param cohortSize The rule, an object of class\n##' \\code{\\linkS4class{CohortSize}}\n##' @param dose the next dose\n##' @param data The data input, an object of class \\code{\\linkS4class{Data}}\n##' @param \\dots additional arguments\n##'\n##' @return the size as integer value\n##'\n##' @export\n##' @keywords methods\nsetGeneric(\"size\",\n           def=\n           function(cohortSize, dose, data, ...){\n               ## if the recommended next dose is NA,\n               ## don't check and return 0\n               if(is.na(dose))\n               {\n                   return(0L)\n               }\n\n               ## there should be no default method,\n               ## therefore just forward to next method!\n               standardGeneric(\"size\")\n           },\n           valueClass=\"integer\")\n\n## --------------------------------------------------\n## The dose range method\n## --------------------------------------------------\n\n##' @describeIn size Determine the cohort size based on the range into which the\n##' next dose falls into\nsetMethod(\"size\",\n          signature=\n          signature(cohortSize=\"CohortSizeRange\",\n                    dose=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(cohortSize, dose, data, ...){\n\n              ## determine in which interval the next dose is\n              interval <-\n                  findInterval(x=dose,\n                               vec=cohortSize@intervals)\n\n              ## so the cohort size is\n              ret <- cohortSize@cohortSize[interval]\n\n              return(ret)\n          })\n\n## --------------------------------------------------\n## The DLT range method\n## --------------------------------------------------\n\n##' @describeIn size Determine the cohort size based on the number of DLTs so\n##' far\nsetMethod(\"size\",\n          signature=\n          signature(cohortSize=\"CohortSizeDLT\",\n                    dose=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(cohortSize, dose, data, ...){\n\n              ## determine how many DLTs have occurred so far\n              dltHappened <- sum(data@y)\n\n              ## determine in which interval this is\n              interval <-\n                  findInterval(x=dltHappened,\n                               vec=cohortSize@DLTintervals)\n\n              ## so the cohort size is\n              ret <- cohortSize@cohortSize[interval]\n\n              return(ret)\n          })\n\n## --------------------------------------------------\n## Size based on maximum of multiple cohort size rules\n## --------------------------------------------------\n\n##' @describeIn size Size based on maximum of multiple cohort size rules\nsetMethod(\"size\",\n          signature=\n          signature(cohortSize=\"CohortSizeMax\",\n                    dose=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(cohortSize, dose, data, ...){\n              ## evaluate the individual cohort size rules\n              ## in the list\n              individualResults <-\n                  sapply(cohortSize@cohortSizeList,\n                         size,\n                         dose=dose,\n                         data=data,\n                         ...)\n\n              ## summarize to obtain overall result\n              overallResult <- max(individualResults)\n\n              return(overallResult)\n          })\n\n## --------------------------------------------------\n## Size based on minimum of multiple cohort size rules\n## --------------------------------------------------\n\n##' @describeIn size Size based on minimum of multiple cohort size rules\nsetMethod(\"size\",\n          signature=\n          signature(cohortSize=\"CohortSizeMin\",\n                    dose=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(cohortSize, dose, data, ...){\n              ## evaluate the individual cohort size rules\n              ## in the list\n              individualResults <-\n                  sapply(cohortSize@cohortSizeList,\n                         size,\n                         dose=dose,\n                         data=data,\n                         ...)\n\n              ## summarize to obtain overall result\n              overallResult <- min(individualResults)\n\n              return(overallResult)\n          })\n\n## --------------------------------------------------\n## Constant cohort size\n## --------------------------------------------------\n\n##' @describeIn size Constant cohort size\nsetMethod(\"size\",\n          signature=\n          signature(cohortSize=\"CohortSizeConst\",\n                    dose=\"ANY\",\n                    data=\"Data\"),\n          def=\n          function(cohortSize, dose, data, ...){\n              return(cohortSize@size)\n          })\n\n\n## --------------------------------------------------\n## Cohort size based on the parts\n## --------------------------------------------------\n\n##' @describeIn size Cohort size based on the parts\nsetMethod(\"size\",\n          signature=\n          signature(cohortSize=\"CohortSizeParts\",\n                    dose=\"ANY\",\n                    data=\"DataParts\"),\n          def=\n          function(cohortSize, dose, data, ...){\n              return(cohortSize@sizes[data@nextPart])\n          })\n\n\n## ============================================================\n",
    "created" : 1436865881826.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3220067095",
    "id" : "775EECCA",
    "lastKnownWriteTime" : 1436866456,
    "path" : "C:/R/Rdev/crmpack/R/Rules-methods.R",
    "project_path" : "R/Rules-methods.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}