{
    "contents" : "#####################################################################################\n## Author: Daniel Sabanes Bove [sabanesd *a*t* roche *.* com]\n## Project: Object-oriented implementation of CRM designs\n##\n## Time-stamp: <[Data-methods.R] by DSB Son 15/02/2015 17:17>\n##\n## Description:\n## Methods for handling the data. Plot ideas taken from bcrm package.\n##\n## History:\n## 30/01/2014   file creation\n## 06/02/2014   add method for conversion to list\n## 17/02/2014   add update methods\n###################################################################################\n\n\n## ============================================================\n\n## --------------------------------------------------\n## Converting Data object to list\n## --------------------------------------------------\n\n\n##' as.list method for the \"GeneralData\" class\n##'\n##' @param x the \\code{\\linkS4class{GeneralData}} object we want to convert\n##' @param \\dots unused\n##' @return a list of all slots in \\code{x}\n##'\n##' @export\n##' @keywords methods\nsetMethod(\"as.list\",\n          signature=\n          signature(x=\"GeneralData\"),\n          def=\n          function(x, ...){\n              nams <- slotNames(x)\n              ret <- lapply(nams,\n                            function(n){\n                                slot(x, n)\n                            })\n              names(ret) <- nams\n              return(ret)\n          })\n\n\n\n## ============================================================\n\n## --------------------------------------------------\n## Plotting the Data objects\n## --------------------------------------------------\n\n\n##' Plot method for the \"Data\" class\n##'\n##' @param x the \\code{\\linkS4class{Data}} object we want to plot\n##' @param y missing\n##' @param blind Logical (default FALSE) if to blind the data. If TRUE, then placebo\n##' subjects are reported by the active dose level of the corresponding cohort and\n##' DLEs are always assigned to the firsts subjects. \n##' @param \\dots not used\n##' @return the \\code{\\link[ggplot2]{ggplot}} object\n##'\n##' @importFrom ggplot2 ggplot geom_point scale_colour_manual xlab ylab aes\n##' scale_y_continuous\n##'\n##' @export\n##' @keywords methods\nsetMethod(\"plot\",\n          signature=\n          signature(x=\"Data\", y=\"missing\"),\n          def=\n          function(x, y, blind=FALSE, ...){\n              if(x@nObs == 0)\n              {\n                  return()\n              }\n\n              df <- data.frame(patient=seq_along(x@x),\n                               dose=x@x,\n                               toxicity=ifelse(x@y==1, \"Yes\", \"No\"),\n                               ID=paste(\" \", x@ID))\n              cols <- c(\"No\" = \"black\",\"Yes\" = \"red\")\n              \n              # If there are placebo, consider this a y=0.0 for the plot\n              if(x@placebo & !blind)\n                    df$dose[df$dose == x@doseGrid[1]] <- 0.0  \n              \n              # This is to blind the data\n              # For each cohort, the placebo is set to the active dose level for that cohort.\n              # In addition, all DLTs are assigned to the first subjects in the cohort\n              if(x@placebo & blind){\n                cohort.id <- unique(x@cohort)   \n                for(iCoh in seq(a=cohort.id)){\n                    filter.coh <- which(x@cohort == cohort.id[iCoh])  \n                    df[filter.coh,\"dose\"] <- max(df[filter.coh,\"dose\"])\n                    df[filter.coh,\"toxicity\"] <- sort(df[filter.coh,\"toxicity\"],\n                                                      decreasing=TRUE)\n                }\n              }\n\n              a <- ggplot(df, aes(x=patient,y=dose)) +\n                  scale_y_continuous(breaks=\n                                     sort(unique(c(0, df$dose))),\n                                     minor_breaks=numeric(),\n                                     limits=c(0, max(df$dose) * 1.1))\n\n              a <- a +\n                  geom_point(aes(shape=toxicity,colour=toxicity),\n                             size=3) +\n                                 scale_colour_manual(values=cols) +\n                                     xlab(\"Patient\") + ylab(\"Dose Level\")\n              \n              if(!blind)\n                  a <- a + geom_text(aes(label=ID, size=2),\n                                     data=df,\n                                     hjust=0, vjust=0.5,\n                                     angle=90, colour=I(\"black\"),\n                                     show_guide = FALSE)\n\n              a <- a + scale_x_continuous(breaks=df$patient,\n                                          minor_breaks=numeric())\n              \n              # add a vertical lines separating sub-sequent cohorts\n              if(x@placebo & length(unique(x@cohort)) > 1)\n                a <- a + geom_vline(xintercept=head(cumsum(table(x@cohort)),n=-1) + 0.5, \n                                    colour=\"green\", \n                                    linetype = \"longdash\")\n              \n              return(a)\n          })\n\n\n## --------------------------------------------------\n## Subclass with additional biomarker information\n## --------------------------------------------------\n\n##' Plot method for the \"DataDual\" class\n##'\n##' @param x the \\code{\\linkS4class{DataDual}} object we want to plot\n##' @param y missing\n##' @param blind Logical (default FALSE) if to blind the data\n##' @param \\dots not used\n##' @return the \\code{\\link[ggplot2]{ggplot}} object\n##'\n##' @importFrom ggplot2 ggplot geom_point scale_colour_manual xlab ylab aes\n##' @importFrom gridExtra arrangeGrob\n##'\n##' @export\n##' @keywords methods\nsetMethod(\"plot\",\n          signature=\n          signature(x=\"DataDual\", y=\"missing\"),\n          def=\n          function(x, y, blind=FALSE, ...){\n              ## call the superclass method, to get the first plot\n              plot1 <- callNextMethod(x, blind=blind, ...)\n\n              ## now to get the second plot\n              df <- data.frame(patient=seq_along(x@x),\n                               dose=x@x,\n                               biomarker=x@w,\n                               toxicity=ifelse(x@y==1, \"Yes\", \"No\"))\n              cols <- c(\"No\" = \"black\",\"Yes\" = \"red\")\n              \n              # If there are placebo, consider this a y=0.0 for the plot\n              if(x@placebo & !blind)\n                  df$dose[df$dose == x@doseGrid[1]] <- 0.0  \n              \n              # This is to blind the data\n              # For each cohort, the placebo is set to the active dose level for that cohort.\n              if(x@placebo & blind){\n                  cohort.id <- unique(x@cohort)   \n                  for(iCoh in seq(a=cohort.id)){\n                      filter.coh <- which(x@cohort == cohort.id[iCoh])  \n                      df[filter.coh,\"dose\"] <- max(df[filter.coh,\"dose\"])\n                  }\n              }\n\n              plot2 <- ggplot(df, aes(x=dose, y=biomarker))\n\n              plot2 <- plot2 +\n                  geom_point(aes(shape=toxicity, colour=toxicity),\n                             size=3) +\n                      scale_colour_manual(values=cols) +\n                          xlab(\"Dose Level\") + ylab(\"Biomarker\")\n              \n              if(!blind)\n                plot2 <- plot2 +\n                  geom_text(data=df,\n                            aes(label=patient, y=biomarker+0.02 * diff(range(biomarker)), size=2), hjust=0,\n                            vjust=0.5, angle=90, colour=I(\"black\"),\n                            show_guide=FALSE)\n\n              ## arrange both plots side by side\n              ret <- gridExtra::arrangeGrob(plot1, plot2, ncol=2)\n              return(ret)\n          })\n\n\n## --------------------------------------------------\n## Plot method for combo data\n## --------------------------------------------------\n\n##' Plot method for the \"DataCombo\" class\n##'\n##' @param x the \\code{\\linkS4class{DataDual}} object we want to plot\n##' @param y missing\n##' @param select two drug names that we want to use for plotting. Defaults\n##' to the first two drug names.\n##' @param shorten relative amount of shortening the arrows. default: 0.05\n##' @param \\dots not used\n##' @return the \\code{\\link[ggplot2]{ggplot}} object\n##'\n##' @importFrom ggplot2 ggplot geom_point scale_colour_manual xlab ylab aes\n##' @importFrom grid arrow\n##' @importFrom gridExtra arrangeGrob\n##'\n##' @export\n##' @keywords methods\nsetMethod(\"plot\",\n          signature=\n          signature(x=\"DataCombo\", y=\"missing\"),\n          def=\n          function(x, y, select=head(x@drugNames, 2L), shorten=0.03, ...){\n\n              ## make sure select contains drug names\n              select <- match.arg(select, choices=x@drugNames,\n                                  several.ok=TRUE)\n\n              ## check shorten parameter\n              stopifnot(shorten >= 0,\n                        shorten < 1)\n\n              ## first plot: (jittered) scatterplot\n              amount1 <- min(diff(x@doseGrid[[select[1]]]))/4\n              amount2 <- min(diff(x@doseGrid[[select[2]]]))/4\n\n              ## create data frame\n              set.seed(12)\n              df <- data.frame(dose1=\n                                   jitter(x@x[, select[1]],\n                                          amount=amount1),\n                               dose2=\n                                   jitter(x@x[, select[2]],\n                                          amount=amount2),\n                               toxicity=ifelse(x@y==1, \"Yes\", \"No\"),\n                               ID=paste(\" \", x@ID))\n              cols <- c(\"No\" = \"black\",\"Yes\" = \"red\")\n\n              ## start the scatterplot\n              plot1 <- ggplot(df, aes(x=dose1, y=dose2)) +\n                  geom_point(aes(shape=toxicity,colour=toxicity),\n                             size=3)\n\n              ## add colour scale and axis labels\n              plot1 <- plot1 +\n                  scale_colour_manual(values=cols) +\n                      xlab(select[1]) + ylab(select[2])\n\n              ## add ID labels\n              plot1 <- plot1 +\n                  geom_text(aes(label=ID, size=1),\n                            data=df,\n                            hjust=-amount1, vjust=0,\n                            angle=0, colour=I(\"black\"),\n                            show_guide = FALSE)\n\n              ## add x axis breaks\n              plot1 <- plot1 +\n                  scale_x_continuous(breaks=x@x[, select[1]],\n                                     minor_breaks=\n                                         setdiff(x@doseGrid[[select[1]]],\n                                                 x@x[, select[1]]),\n                                     limits=c(0, max(df$dose1)))\n\n              ## add y axis breaks\n              plot1 <- plot1 +\n                  scale_y_continuous(breaks=x@x[, select[2]],\n                                     minor_breaks=\n                                         setdiff(x@doseGrid[[select[2]]],\n                                                 x@x[, select[2]]),\n                                     limits=c(0, max(df$dose2)))\n              ## todo: later try to show summaries for each tried dose combination,\n              ## like small barcharts or similar. will take more work...\n\n              ## second plot: show evolution of cohorts.\n\n              ## first find out which points are we going to plot\n              cohortCoords <- as.data.frame(unique(cbind(x@x[, select],\n                                                         cohort=x@cohort)))\n              names(cohortCoords) <- c(\"x\", \"y\", \"cohort\")\n\n              ## Plot the base graph minus the edges\n              plot2 <- ggplot() +\n                  geom_point(data=cohortCoords,\n                             aes(x=x, y=y), size=6, inherit.aes = FALSE) +\n                                 geom_text(data=cohortCoords,\n                                           aes(x=x, y=y, label=as.character(cohort)),\n                                           inherit.aes = FALSE, color=\"white\", size=4)\n\n              ## todo: later revisit this plot, maybe starting both axes at 0\n              ## is not optimal.\n              ex1 <- max(df$dose1) * 1.1\n              ex2 <- max(df$dose2) * 1.1\n\n              ## add x axis breaks\n              plot2 <- plot2 +\n                  scale_x_continuous(breaks=x@x[, select[1]],\n                                     minor_breaks=\n                                         setdiff(x@doseGrid[[select[1]]],\n                                                 x@x[, select[1]]),\n                                     limits=c(0, ex1))\n\n              ## add y axis breaks\n              plot2 <- plot2 +\n                  scale_y_continuous(breaks=x@x[, select[2]],\n                                     minor_breaks=\n                                         setdiff(x@doseGrid[[select[2]]],\n                                                 x@x[, select[2]]),\n                                     limits=c(0, ex2))\n\n              ## calculate the arrows\n              dfArrows <- cbind(head(subset(cohortCoords, select=c(\"x\", \"y\")),\n                                     -1L),\n                                tail(subset(cohortCoords, select=c(\"x\", \"y\")),\n                                     -1L))\n              names(dfArrows) <- c(\"x\", \"y\", \"xend\", \"yend\")\n\n              ## shorten arrows as requested\n              dfArrows$x <- dfArrows$x / ex1\n              dfArrows$y <- dfArrows$y / ex2\n              dfArrows$xend <- dfArrows$xend / ex1\n              dfArrows$yend <- dfArrows$yend / ex2\n\n              dfArrows$dx <- dfArrows$xend - dfArrows$x\n              dfArrows$dy <- dfArrows$yend - dfArrows$y\n              dfArrows$dist <- sqrt(dfArrows$dx^2 + dfArrows$dy^2)\n              dfArrows$x <- dfArrows$x +\n                  shorten / dfArrows$dist * dfArrows$dx\n              dfArrows$y <- dfArrows$y +\n                  shorten / dfArrows$dist * dfArrows$dy\n              dfArrows$xend <- dfArrows$xend -\n                  shorten / dfArrows$dist  * dfArrows$dx\n              dfArrows$yend <- dfArrows$yend -\n                  shorten / dfArrows$dist  * dfArrows$dy\n\n              dfArrows$x <- dfArrows$x * ex1\n              dfArrows$y <- dfArrows$y * ex2\n              dfArrows$xend <- dfArrows$xend * ex1\n              dfArrows$yend <- dfArrows$yend * ex2\n\n              ## Add the edges\n              plot2 <- plot2 +\n                  geom_segment(aes(x=x, y=y, xend = xend,\n                                   yend = yend),\n                               size = 1,\n                               data = dfArrows,\n                               arrow = grid::arrow(length = grid::unit(1, units=\"mm\")))\n\n              plot2 <- plot2 + xlab(select[1]) + ylab(select[2])\n\n              ## arrange both plots side by side\n              ret <- gridExtra::arrangeGrob(plot1, plot2, ncol=2)\n              return(ret)\n          })\n\n\n\n## ============================================================\n\n## --------------------------------------------------\n## Update a Data object\n## --------------------------------------------------\n\n\n##' Update method for the \"Data\" class\n##'\n##' Add new data to the \\code{\\linkS4class{Data}} object\n##'\n##' @param object the old \\code{\\linkS4class{Data}} object\n##' @param x the dose level (one level only!)\n##' @param y the DLT vector (0/1 vector), for all patients in this cohort\n##' @param ID the patient IDs\n##' @param newCohort logical: if TRUE (default) the new data are assigned \n##' to a new cohort\n##' @param \\dots not used\n##' @return the new \\code{\\linkS4class{Data}} object\n##'\n##' @export\n##' @keywords methods\nsetMethod(\"update\",\n          signature=\n          signature(object=\"Data\"),\n          def=\n          function(object,\n                   x,\n                   y,\n                   ID=(if(length(object@ID)) max(object@ID) else 0L) + seq_along(y),\n                   newCohort=TRUE,\n                   ...){\n\n              ## some checks\n              stopifnot(is.scalar(x),\n                        all(y %in% c(0, 1)))\n\n              ## which grid level is the dose?\n              gridLevel <- match(x, object@doseGrid)\n\n              ## add it to the data\n              if(is.na(gridLevel))\n              {\n                  stop(\"dose is not on grid\")\n              } else {\n                  object@xLevel <- c(object@xLevel,\n                                     rep(gridLevel,\n                                         length(y)))\n              }\n\n              ## increment sample size\n              object@nObs <- object@nObs + length(y)\n\n              ## add dose\n              object@x <- c(object@x,\n                            rep(x,\n                                length(y)))\n\n              ## add DLT data\n              object@y <- c(object@y, as.integer(y))\n\n              ## add ID\n              object@ID <- c(object@ID, ID)\n\n              ## add cohort number\n              if(newCohort){\n                    object@cohort <- c(object@cohort,\n                                       rep(max(tail(object@cohort, 1L), 0L) + 1L,\n                                           length(y)))\n              }else{\n                    object@cohort <- c(object@cohort,\n                                     rep(max(tail(object@cohort, 1L), 0L),\n                                         length(y)))\n              }\n\n              ## return the object\n              return(object)\n          })\n\n\n## --------------------------------------------------\n## Update a DataParts object\n## --------------------------------------------------\n\n##' Update method for the \"DataParts\" class\n##'\n##' Add new data to the \\code{\\linkS4class{DataParts}} object\n##'\n##' @param object the old \\code{\\linkS4class{DataParts}} object\n##' @param x the dose level (one level only!)\n##' @param y the DLT vector (0/1 vector), for all patients in this cohort\n##' @param ID the patient IDs\n##' @param \\dots not used\n##' @return the new \\code{\\linkS4class{DataParts}} object\n##'\n##' @export\n##' @keywords methods\nsetMethod(\"update\",\n          signature=\n          signature(object=\"DataParts\"),\n          def=\n          function(object,\n                   x,\n                   y,\n                   ID=(if(length(object@ID)) max(object@ID) else 0L) + seq_along(y),\n                   ...){\n\n              ## first do the usual things as for Data objects\n              object <- callNextMethod(object=object, x=x, y=y, ID=ID, ...)\n\n              ## update the part information\n              object@part <- c(object@part,\n                               rep(object@nextPart,\n                                   length(y)))\n\n              ## now decide which part the next cohort will belong to:\n              ## only if the nextPart was 1, it can potentially be required to\n              ## change it to 2 (once it is 2, it stays)\n              if(object@nextPart == 1L)\n              {\n                  ## if there was a DLT in one of the cohorts,\n                  ## or if the current dose was the highest from part 1:\n                  if(any(object@y == 1L) || x == max(object@part1Ladder))\n                  {\n                      ## then this closes part 1 and the next cohort will\n                      ## be from part 2:\n                      object@nextPart <- 2L\n                  }\n              }\n\n              ## return the object\n              return(object)\n          })\n\n## --------------------------------------------------\n## Update a DataDual object\n## --------------------------------------------------\n\n##' Update method for the \"DataDual\" class\n##'\n##' Add new data to the \\code{\\linkS4class{DataDual}} object\n##'\n##' @param object the old \\code{\\linkS4class{DataDual}} object\n##' @param x the dose level (one level only!)\n##' @param y the DLT vector (0/1 vector), for all patients in this cohort\n##' @param w the biomarker vector, for all patients in this cohort\n##' @param ID the patient IDs\n##' @param newCohort logical: if TRUE (default) the new data are assigned \n##' to a new cohort\n##' @param \\dots not used\n##' @return the new \\code{\\linkS4class{DataDual}} object\n##'\n##' @export\n##' @keywords methods\nsetMethod(\"update\",\n          signature=\n          signature(object=\"DataDual\"),\n          def=\n          function(object,\n                   x,\n                   y,\n                   w,\n                   newCohort=TRUE,\n                   ID=(if(length(object@ID)) max(object@ID) else 0L) + seq_along(y),\n                   ...){\n\n              ## first do the usual things as for Data objects\n              object <- callNextMethod(object=object, x=x, y=y, ID=ID, \n                                       newCohort=newCohort, ...)\n\n              ## update the biomarker information\n              object@w <- c(object@w,\n                            w)\n\n              ## return the object\n              return(object)\n          })\n\n## --------------------------------------------------\n## Update a DataCombo object\n## --------------------------------------------------\n\n##' Update method for the \"DataCombo\" class\n##'\n##' Add new data to the \\code{\\linkS4class{DataCombo}} object\n##'\n##' @param object the old \\code{\\linkS4class{DataCombo}} object\n##' @param x the dose levels vector (one dose level combination only!)\n##' @param y the DLT vector (0/1 vector), for all patients in this cohort\n##' @param ID the patient IDs\n##' @param \\dots not used\n##' @return the new \\code{\\linkS4class{DataCombo}} object\n##'\n##' @export\n##' @keywords methods\nsetMethod(\"update\",\n          signature=\n          signature(object=\"DataCombo\"),\n          def=\n          function(object,\n                   x,\n                   y,\n                   ID=(if(length(object@ID)) max(object@ID) else 0L) + seq_along(y),\n                   ...){\n\n              ## checks\n              stopifnot(is.numeric(x),\n                        identical(length(x), object@nDrugs),\n                        identical(names(x), object@drugNames))\n\n              ## which grid levels are the doses?\n              gridLevels <- integer(object@nDrugs)\n              names(gridLevels) <- object@drugNames\n              for(k in object@drugNames)\n              {\n                  gridLevels[k] <- match(x=x[k],\n                                         table=object@doseGrid[[k]])\n                  if(is.na(gridLevels[k]))\n                  {\n                      stop(paste(\"dose for drug\", k, \"is not on dose grid\"))\n                  }\n              }\n\n              ## add to the xLevel matrix\n              object@xLevel <- rbind(object@xLevel,\n                                     matrix(data=gridLevels,\n                                            nrow=length(y),\n                                            ncol=2L,\n                                            byrow=TRUE))\n\n              ## increment sample size\n              object@nObs <- object@nObs + length(y)\n\n              ## add dose combo\n              object@x <- rbind(object@x,\n                                matrix(data=x,\n                                       nrow=length(y),\n                                       ncol=2L,\n                                       byrow=TRUE))\n\n              ## add DLT data\n              object@y <- c(object@y, as.integer(y))\n\n              ## add ID\n              object@ID <- c(object@ID, ID)\n\n              ## add cohort number\n              object@cohort <- c(object@cohort,\n                                 rep(max(tail(object@cohort, 1L), 0L) + 1L,\n                                     length(y)))\n\n              ## return the object\n              return(object)\n          })\n\n\n\n\n\n## ============================================================\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1436861292039.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "539483474",
    "id" : "AF95ACA6",
    "lastKnownWriteTime" : 1436861419,
    "path" : "C:/R/Rdev/crmpack/R/Data-methods.R",
    "project_path" : "R/Data-methods.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}